using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;
using System.Collections;
using System.Text.RegularExpressions;
using WIN_FFT;
using System.Runtime.InteropServices;

//using System.Text.RegularExpressions;

using NeuroSky.ThinkGear;
//using NeuroSky.ThinkGear.Parser;

using NeuroSky.ThinkGear.Algorithms;


namespace NeuroSky.MindView {
    public partial class Launcher : Form {
        
        private static Connector connector;
        RespiratoryRate respRate;
        complex[] Complex;
        complex fft;
        double[] fft_amp;
        MainForm mainForm;
        Device device;
        RecognitionRecordingGUI identificationRecordingGUI;

        private TGHrv tgHRV;                //the RR interval detection algorithm
        
        private int tgHRVresult;            //output of the TGHrv algorithm
        private int tgHRVresultInMS;     //output of the TGHrv algorithm in MSec

        private byte[] bytesToSend;     //bytes to send for EGO
        private int rawCounter;         //counter for delay of EGO output
        private int delay;              //delay for lead on/lead off
        private byte tri_byte;

        private int bufferSize_hp = 1009;       //length of the low pass filter
        private int bufferSize_hp_600 = 1423;
        private int FFT_RAW;
        private double[] FFT_buffer;
        private double[] sample_Before;
        public double[] sample_After=new double[512];

        //bandpass filter, 0.5 to 2Hz, 35 to 36.5Hz, equiripple
        private double[] hp_coeff = new double[1009] { 4.97842e-005, -1.6073e-005, -4.38342e-005, -9.0004e-005, -0.000153298, -0.000230318, -0.000314971, -0.000398489, -0.000469973, -0.000517472, -0.000529423, -0.000496331, -0.000412407, -0.000276935, -9.50954e-005, 0.000121915, 0.000357604, 0.000591691, 0.000802295, 0.000968525, 0.00107317, 0.00110508, 0.00106089, 0.000945738, 0.000772936, 0.000562427, 0.000338361, 0.000125981, -5.16857e-005, -0.000176926, -0.00023969, -0.000238881, -0.000182311, -8.54013e-005, 3.12379e-005, 0.000144963, 0.00023462, 0.000283763, 0.000283099, 0.000231661, 0.00013688, 1.33839e-005, -0.000120031, -0.000242959, -0.000337238, -0.000389688, -0.000394337, -0.000353272, -0.000276203, -0.000178694, -7.94472e-005, 2.9522e-006, 5.32201e-005, 6.19903e-005, 2.73595e-005, -4.48451e-005, -0.000142171, -0.000247778, -0.000343455, -0.000412854, -0.000444393, -0.000433287, -0.000382386, -0.000301629, -0.000206258, -0.000114059, -4.21593e-005, -3.92132e-006, -6.54742e-006, -4.97674e-005, -0.000125889, -0.00022117, -0.00031833, -0.000399692, -0.000450426, -0.000461245, -0.000430149, -0.000362831, -0.000271676, -0.000173472, -8.64117e-005, -2.67399e-005, -5.66692e-006, -2.74003e-005, -8.81832e-005, -0.000177021, -0.0002776, -0.000371292, -0.000440564, -0.000472258, -0.000460059, -0.000405741, -0.000318915, -0.000215329, -0.000114006, -3.37416e-005, 1.03968e-005, 9.91564e-006, -3.54469e-005, -0.000117579, -0.0002214, -0.000327588, -0.000416124, -0.000470027, -0.000478549, -0.000439269, -0.000358643, -0.000250928, -0.000135622, -3.38883e-005, 3.53741e-005, 5.90895e-005, 3.25324e-005, -3.96701e-005, -0.000144263, -0.000261735, -0.000369865, -0.000447836, -0.000480153, -0.000459636, -0.000388857, -0.000279818, -0.000151863, -2.81216e-005, 6.87087e-005, 0.000120668, 0.000117933, 6.08078e-005, -4.01972e-005, -0.000166163, -0.000293185, -0.000396764, -0.000456395, -0.000459465, -0.000403747, -0.000297973, -0.000160372, -1.54059e-005, 0.000110719, 0.000194937, 0.000221695, 0.000185993, 9.44788e-005, -3.5604e-005, -0.000179484, -0.000309383, -0.000399686, -0.000431767, -0.000397602, -0.00030144, -0.000159206, 4.30025e-006, 0.000159918, 0.000279517, 0.000341293, 0.000333965, 0.000259055, 0.000130806, -2.62808e-005, -0.000181874, -0.000305429, -0.00037189, -0.000366495, -0.000287715, -0.000147738, 2.95778e-005, 0.000213015, 0.000369718, 0.000471346, 0.000499459, 0.000449139, 0.000330132, 0.000165249, -1.37043e-005, -0.000171755, -0.000277278, -0.000307988, -0.000255277, -0.000126043, 5.8352e-005, 0.000265863, 0.000459606, 0.000604713, 0.000674904, 0.000657563, 0.000556324, 0.000390649, 0.00019242, 1.50962e-007, -0.000148142, -0.00022209, -0.000204796, -9.62312e-005, 8.64968e-005, 0.000312086, 0.000540686, 0.000731258, 0.000849261, 0.000873244, 0.000799081, 0.000641031, 0.000429332, 0.000204786, 1.12534e-005, -0.000112549, -0.000140389, -6.36667e-005, 0.000106707, 0.000342042, 0.000600983, 0.000837082, 0.00100745, 0.00108085, 0.00104381, 0.000903343, 0.00068604, 0.000433322, 0.000193907, 1.47609e-005, -6.77566e-005, -3.48957e-005, 0.000110684, 0.000345075, 0.000627282, 0.000906666, 0.00113231, 0.00126258, 0.00127311, 0.00116164, 0.000948794, 0.00067454, 0.000390999, 0.00015282, 6.93962e-006, -1.63582e-005, 9.06015e-005, 0.000311087, 0.000606724, 0.000924384, 0.00120594, 0.00139911, 0.00146741, 0.00139722, 0.00120072, 0.000914022, 0.00059069, 0.000291984, 7.54329e-005, -1.60388e-005, 3.75807e-005, 0.000229277, 0.000525903, 0.000874017, 0.00120961, 0.00147, 0.00160562, 0.00158958, 0.00142303, 0.00113543, 0.000779412, 0.000421231, 0.00012853, -4.23778e-005, -5.72837e-005, 8.91401e-005, 0.000371887, 0.00073985, 0.00112504, 0.0014551, 0.00166687, 0.00171843, 0.00159726, 0.00132311, 0.00094477, 0.000531317, 0.000159446, -0.000100848, -0.000199552, -0.00011636, 0.000135044, 0.000509035, 0.000936128, 0.0013357, 0.00163096, 0.00176352, 0.00170461, 0.00146099, 0.00107421, 0.000613365, 0.00016248, -0.000195056, -0.000392206, -0.000391161, -0.000190913, 0.00017197, 0.000629648, 0.00109528, 0.0014791, 0.00170522, 0.00172621, 0.00153243, 0.00115445, 0.000657917, 0.000131795, -0.000328076, -0.000636886, -0.000737016, -0.000609315, -0.000277325, 0.000196479, 0.000721825, 0.00119721, 0.00152882, 0.00164837, 0.00152629, 0.00117802, 0.000661752, 6.8175e-005, -0.000496062, -0.0009282, -0.00114878, -0.00111701, -0.000839032, -0.000367587, 0.000207202, 0.000774182, 0.00122177, 0.00145895, 0.00143281, 0.00113906, 0.00062371, -2.47923e-005, -0.000691529, -0.00125632, -0.00161627, -0.00170545, -0.00150797, -0.00106174, -0.0004523, 0.000202544, 0.000774355, 0.0011481, 0.00124405, 0.00103341, 0.000544639, -0.000140981, -0.000903717, -0.00160731, -0.00212435, -0.0023605, -0.00227276, -0.00187856, -0.00125346, -0.000517976, 0.000184397, 0.000713794, 0.000960428, 0.000865822, 0.000434742, -0.00026456, -0.00111209, -0.00195777, -0.00264925, -0.00306051, -0.00311619, -0.00280663, -0.00219097, -0.00138724, -0.000551165, 0.000152457, 0.000580703, 0.000639875, 0.000304097, -0.000378518, -0.00129354, -0.00228053, -0.00316244, -0.00377866, -0.00401565, -0.00382924, -0.00325438, -0.00240002, -0.00143006, -0.00053352, 0.00011063, 0.000367443, 0.000172336, -0.000455299, -0.00141404, -0.00253787, -0.00362621, -0.00448102, -0.00494422, -0.00492835, -0.0044346, -0.00355442, -0.00245424, -0.00134562, -0.000446322, 6.06444e-005, 6.23512e-005, -0.000461193, -0.0014312, -0.00268275, -0.00399399, -0.00512671, -0.00587093, -0.0060852, -0.00572491, -0.00485295, -0.0036304, -0.00228845, -0.0010864, -0.000263448, 7.05746e-006, -0.000348085, -0.00128559, -0.00265096, -0.0042048, -0.00566592, -0.00676332, -0.00728765, -0.00713238, -0.00631662, -0.00498492, -0.00338331, -0.00181561, -0.000587673, 5.03948e-005, -4.69781e-005, -0.000890329, -0.00234927, -0.00417302, -0.00603419, -0.00758839, -0.00853877, -0.00869352, -0.00800543, -0.00658532, -0.00468611, -0.00265964, -0.000893409, 0.000261468, 0.000557815, -9.7344e-005, -0.0016199, -0.00375832, -0.00613523, -0.00831414, -0.00987974, -0.0105172, -0.0100752, -0.00860142, -0.00634057, -0.00369663, -0.00116275, 0.000768088, 0.0016962, 0.00139464, -0.000140363, -0.00267874, -0.00578933, -0.00891179, -0.0114562, -0.0129129, -0.0129523, -0.0114965, -0.00874675, -0.00516073, -0.00138027, 0.00187893, 0.00395757, 0.00437993, 0.00295426, -0.000173413, -0.00452491, -0.00935723, -0.0137831, -0.0169265, -0.018086, -0.0168787, -0.0133363, -0.0079323, -0.00153294, 0.00472761, 0.00962952, 0.0120805, 0.011325, 0.00711448, -0.000194145, -0.00963208, -0.0197124, -0.0286155, -0.0344426, -0.0355015, -0.0305815, -0.0191755, -0.00161144, 0.0209306, 0.0465231, 0.0727066, 0.0967898, 0.116191, 0.128774, 0.133132, 0.128774, 0.116191, 0.0967898, 0.0727066, 0.0465231, 0.0209306, -0.00161144, -0.0191755, -0.0305815, -0.0355015, -0.0344426, -0.0286155, -0.0197124, -0.00963208, -0.000194145, 0.00711448, 0.011325, 0.0120805, 0.00962952, 0.00472761, -0.00153294, -0.0079323, -0.0133363, -0.0168787, -0.018086, -0.0169265, -0.0137831, -0.00935723, -0.00452491, -0.000173413, 0.00295426, 0.00437993, 0.00395757, 0.00187893, -0.00138027, -0.00516073, -0.00874675, -0.0114965, -0.0129523, -0.0129129, -0.0114562, -0.00891179, -0.00578933, -0.00267874, -0.000140363, 0.00139464, 0.0016962, 0.000768088, -0.00116275, -0.00369663, -0.00634057, -0.00860142, -0.0100752, -0.0105172, -0.00987974, -0.00831414, -0.00613523, -0.00375832, -0.0016199, -9.7344e-005, 0.000557815, 0.000261468, -0.000893409, -0.00265964, -0.00468611, -0.00658532, -0.00800543, -0.00869352, -0.00853877, -0.00758839, -0.00603419, -0.00417302, -0.00234927, -0.000890329, -4.69781e-005, 5.03948e-005, -0.000587673, -0.00181561, -0.00338331, -0.00498492, -0.00631662, -0.00713238, -0.00728765, -0.00676332, -0.00566592, -0.0042048, -0.00265096, -0.00128559, -0.000348085, 7.05746e-006, -0.000263448, -0.0010864, -0.00228845, -0.0036304, -0.00485295, -0.00572491, -0.0060852, -0.00587093, -0.00512671, -0.00399399, -0.00268275, -0.0014312, -0.000461193, 6.23512e-005, 6.06444e-005, -0.000446322, -0.00134562, -0.00245424, -0.00355442, -0.0044346, -0.00492835, -0.00494422, -0.00448102, -0.00362621, -0.00253787, -0.00141404, -0.000455299, 0.000172336, 0.000367443, 0.00011063, -0.00053352, -0.00143006, -0.00240002, -0.00325438, -0.00382924, -0.00401565, -0.00377866, -0.00316244, -0.00228053, -0.00129354, -0.000378518, 0.000304097, 0.000639875, 0.000580703, 0.000152457, -0.000551165, -0.00138724, -0.00219097, -0.00280663, -0.00311619, -0.00306051, -0.00264925, -0.00195777, -0.00111209, -0.00026456, 0.000434742, 0.000865822, 0.000960428, 0.000713794, 0.000184397, -0.000517976, -0.00125346, -0.00187856, -0.00227276, -0.0023605, -0.00212435, -0.00160731, -0.000903717, -0.000140981, 0.000544639, 0.00103341, 0.00124405, 0.0011481, 0.000774355, 0.000202544, -0.0004523, -0.00106174, -0.00150797, -0.00170545, -0.00161627, -0.00125632, -0.000691529, -2.47923e-005, 0.00062371, 0.00113906, 0.00143281, 0.00145895, 0.00122177, 0.000774182, 0.000207202, -0.000367587, -0.000839032, -0.00111701, -0.00114878, -0.0009282, -0.000496062, 6.8175e-005, 0.000661752, 0.00117802, 0.00152629, 0.00164837, 0.00152882, 0.00119721, 0.000721825, 0.000196479, -0.000277325, -0.000609315, -0.000737016, -0.000636886, -0.000328076, 0.000131795, 0.000657917, 0.00115445, 0.00153243, 0.00172621, 0.00170522, 0.0014791, 0.00109528, 0.000629648, 0.00017197, -0.000190913, -0.000391161, -0.000392206, -0.000195056, 0.00016248, 0.000613365, 0.00107421, 0.00146099, 0.00170461, 0.00176352, 0.00163096, 0.0013357, 0.000936128, 0.000509035, 0.000135044, -0.00011636, -0.000199552, -0.000100848, 0.000159446, 0.000531317, 0.00094477, 0.00132311, 0.00159726, 0.00171843, 0.00166687, 0.0014551, 0.00112504, 0.00073985, 0.000371887, 8.91401e-005, -5.72837e-005, -4.23778e-005, 0.00012853, 0.000421231, 0.000779412, 0.00113543, 0.00142303, 0.00158958, 0.00160562, 0.00147, 0.00120961, 0.000874017, 0.000525903, 0.000229277, 3.75807e-005, -1.60388e-005, 7.54329e-005, 0.000291984, 0.00059069, 0.000914022, 0.00120072, 0.00139722, 0.00146741, 0.00139911, 0.00120594, 0.000924384, 0.000606724, 0.000311087, 9.06015e-005, -1.63582e-005, 6.93962e-006, 0.00015282, 0.000390999, 0.00067454, 0.000948794, 0.00116164, 0.00127311, 0.00126258, 0.00113231, 0.000906666, 0.000627282, 0.000345075, 0.000110684, -3.48957e-005, -6.77566e-005, 1.47609e-005, 0.000193907, 0.000433322, 0.00068604, 0.000903343, 0.00104381, 0.00108085, 0.00100745, 0.000837082, 0.000600983, 0.000342042, 0.000106707, -6.36667e-005, -0.000140389, -0.000112549, 1.12534e-005, 0.000204786, 0.000429332, 0.000641031, 0.000799081, 0.000873244, 0.000849261, 0.000731258, 0.000540686, 0.000312086, 8.64968e-005, -9.62312e-005, -0.000204796, -0.00022209, -0.000148142, 1.50962e-007, 0.00019242, 0.000390649, 0.000556324, 0.000657563, 0.000674904, 0.000604713, 0.000459606, 0.000265863, 5.8352e-005, -0.000126043, -0.000255277, -0.000307988, -0.000277278, -0.000171755, -1.37043e-005, 0.000165249, 0.000330132, 0.000449139, 0.000499459, 0.000471346, 0.000369718, 0.000213015, 2.95778e-005, -0.000147738, -0.000287715, -0.000366495, -0.00037189, -0.000305429, -0.000181874, -2.62808e-005, 0.000130806, 0.000259055, 0.000333965, 0.000341293, 0.000279517, 0.000159918, 4.30025e-006, -0.000159206, -0.00030144, -0.000397602, -0.000431767, -0.000399686, -0.000309383, -0.000179484, -3.5604e-005, 9.44788e-005, 0.000185993, 0.000221695, 0.000194937, 0.000110719, -1.54059e-005, -0.000160372, -0.000297973, -0.000403747, -0.000459465, -0.000456395, -0.000396764, -0.000293185, -0.000166163, -4.01972e-005, 6.08078e-005, 0.000117933, 0.000120668, 6.87087e-005, -2.81216e-005, -0.000151863, -0.000279818, -0.000388857, -0.000459636, -0.000480153, -0.000447836, -0.000369865, -0.000261735, -0.000144263, -3.96701e-005, 3.25324e-005, 5.90895e-005, 3.53741e-005, -3.38883e-005, -0.000135622, -0.000250928, -0.000358643, -0.000439269, -0.000478549, -0.000470027, -0.000416124, -0.000327588, -0.0002214, -0.000117579, -3.54469e-005, 9.91564e-006, 1.03968e-005, -3.37416e-005, -0.000114006, -0.000215329, -0.000318915, -0.000405741, -0.000460059, -0.000472258, -0.000440564, -0.000371292, -0.0002776, -0.000177021, -8.81832e-005, -2.74003e-005, -5.66692e-006, -2.67399e-005, -8.64117e-005, -0.000173472, -0.000271676, -0.000362831, -0.000430149, -0.000461245, -0.000450426, -0.000399692, -0.00031833, -0.00022117, -0.000125889, -4.97674e-005, -6.54742e-006, -3.92132e-006, -4.21593e-005, -0.000114059, -0.000206258, -0.000301629, -0.000382386, -0.000433287, -0.000444393, -0.000412854, -0.000343455, -0.000247778, -0.000142171, -4.48451e-005, 2.73595e-005, 6.19903e-005, 5.32201e-005, 2.9522e-006, -7.94472e-005, -0.000178694, -0.000276203, -0.000353272, -0.000394337, -0.000389688, -0.000337238, -0.000242959, -0.000120031, 1.33839e-005, 0.00013688, 0.000231661, 0.000283099, 0.000283763, 0.00023462, 0.000144963, 3.12379e-005, -8.54013e-005, -0.000182311, -0.000238881, -0.00023969, -0.000176926, -5.16857e-005, 0.000125981, 0.000338361, 0.000562427, 0.000772936, 0.000945738, 0.00106089, 0.00110508, 0.00107317, 0.000968525, 0.000802295, 0.000591691, 0.000357604, 0.000121915, -9.50954e-005, -0.000276935, -0.000412407, -0.000496331, -0.000529423, -0.000517472, -0.000469973, -0.000398489, -0.000314971, -0.000230318, -0.000153298, -9.0004e-005, -4.38342e-005, -1.6073e-005, 4.97842e-005 };
        private double[] hp_coeff_600 = new double[1423] { -5.41775027494366e-05, 2.38303222087342e-07, 8.00629085771220e-06, 2.10398451631984e-05, 3.90557623958455e-05, 6.13435329217216e-05, 8.67428160834360e-05, 0.000113656608320366, 0.000140160761904866, 0.000164139032796616, 0.000183491740843345, 0.000196333303102994, 0.000201218316150325, 0.000197305593707142, 0.000184502672153669, 0.000163505341911061, 0.000135789425416030, 0.000103484385828821, 6.92039315241304e-05, 3.57814289702832e-05, 6.00374585929518e-06, -1.76965961254198e-05, -3.34844315967768e-05, -4.03412877224400e-05, -3.81593840161193e-05, -2.77716078061957e-05, -1.08383547840727e-05, 1.03184022118271e-05, 3.29950927553473e-05, 5.43887830023354e-05, 7.19403366627801e-05, 8.36103258691585e-05, 8.81445625094016e-05, 8.51892241452302e-05, 7.53392372518753e-05, 6.00067448127893e-05, 4.12686580912749e-05, 2.15880852311731e-05, 3.58404452313536e-06, -1.03943319642062e-05, -1.87404866689510e-05, -2.02672709683160e-05, -1.49763353864476e-05, -3.62799702821184e-06, 1.21705236068999e-05, 3.02417074753783e-05, 4.81006125089142e-05, 6.32988878999027e-05, 7.37382509553564e-05, 7.79573934769908e-05, 7.53241608332524e-05, 6.61268020961053e-05, 5.15389284412098e-05, 3.34662423243267e-05, 1.42952682713769e-05, -3.42872766388902e-06, -1.73416653639437e-05, -2.55848978527061e-05, -2.70562042819254e-05, -2.15710707875482e-05, -9.89225641009268e-06, 6.35604391059514e-06, 2.49062438268540e-05, 4.31430424185021e-05, 5.84659873641117e-05, 6.86374216881549e-05, 7.20993778931555e-05, 6.81834244175913e-05, 5.72241611661594e-05, 4.05197220782586e-05, 2.01816895353178e-05, -1.15718801963570e-06, -2.06892397783733e-05, -3.58286655851685e-05, -4.45452849688659e-05, -4.56631460603750e-05, -3.90290549970413e-05, -2.55882629228275e-05, -7.21426288533426e-06, 1.35330238338318e-05, 3.36502590583024e-05, 5.02463067480140e-05, 6.08100022993460e-05, 6.36410056284099e-05, 5.80606492765233e-05, 4.45396499136897e-05, 2.46439352867134e-05, 8.43119069287522e-07, -2.38174205220706e-05, -4.61236155795391e-05, -6.31321800854717e-05, -7.25804047088175e-05, -7.32084427297287e-05, -6.49535468335046e-05, -4.89773592885346e-05, -2.75306433932657e-05, -3.65824575202301e-06, 1.92027265469786e-05, 3.76930612825050e-05, 4.89897614119904e-05, 5.12095937685197e-05, 4.36805555605361e-05, 2.70633563780013e-05, 3.27772934680794e-06, -2.47343931280551e-05, -5.34027390304918e-05, -7.90004021132727e-05, -9.81606287047804e-05, -0.000108339992244031, -0.000108195509658728, -9.77822816313704e-05, -7.85765153187353e-05, -5.32855901105837e-05, -2.55142529896370e-05, 7.23746795272482e-07, 2.15469672608618e-05, 3.37660961651943e-05, 3.52981070679250e-05, 2.54961505010855e-05, 5.28389555030305e-06, -2.29972452974647e-05, -5.58260758494103e-05, -8.90092244647987e-05, -0.000118221883532868, -0.000139613954709824, -0.000150343558612554, -0.000148990441494891, -0.000135775793401282, -0.000112561010433072, -8.26205757416121e-05, -5.02146052065163e-05, -2.00213778873869e-05, 3.50315617803419e-06, 1.67407793106498e-05, 1.74291366788252e-05, 4.99396525712985e-06, -1.93382759070846e-05, -5.26820818136178e-05, -9.08563492744216e-05, -0.000128942310692718, -0.000161943673850021, -0.000185481193813108, -0.000196402131357741, -0.000193241341498850, -0.000176445617716202, -0.000148352207236388, -0.000112894524725543, -7.50948676537967e-05, -4.03804829973491e-05, -1.38485241123716e-05, 4.48390846925062e-07, 6.89974224852674e-08, -1.54387457896716e-05, -4.44483573110374e-05, -8.34392755369214e-05, -0.000127463324843792, -0.000170775987070716, -0.000207640076867084, -0.000233112830152265, -0.000243723775900697, -0.000238006886056999, -0.000216711191948205, -0.000182751984191670, -0.000140836174312898, -9.68473814575550e-05, -5.70517384690742e-05, -2.72394560893955e-05, -1.19182902273736e-05, -1.36687079690515e-05, -3.27572928598435e-05, -6.70583967549565e-05, -0.000112310184268446, -0.000162663334706720, -0.000211466481748968, -0.000252167179506565, -0.000279221780616026, -0.000288872187396555, -0.000279698323161388, -0.000252848593193085, -0.000211929405301880, -0.000162541576769853, -0.000111544576430454, -6.61245603834870e-05, -3.28142751672934e-05, -1.65748909128861e-05, -2.00902358579179e-05, -4.33518875070623e-05, -8.36250450795108e-05, -0.000135775521151931, -0.000192944853870151, -0.000247460409030712, -0.000291892905660510, -0.000320078473574568, -0.000327993797126448, -0.000314337010183019, -0.000280770008237615, -0.000231714037984559, -0.000173796326250942, -0.000114970969442428, -6.34298179693306e-05, -2.64892382868700e-05, -9.55499119629498e-06, -1.53517033736746e-05, -4.35009442826526e-05, -9.05251787859542e-05, -0.000150280040234256, -0.000214759899196551, -0.000275176142504607, -0.000323155992060342, -0.000351907719801929, -0.000357180130205678, -0.000337893539468504, -0.000296333745328554, -0.000237892289803654, -0.000170365025562497, -0.000102917195730211, -4.48344575877782e-05, -4.24647563137697e-06, 1.30195358555482e-05, 4.27359563634318e-06, -2.96124316508882e-05, -8.42765307013823e-05, -0.000152409419307943, -0.000224724379471763, -0.000291205174077100, -0.000342485297930006, -0.000371143828990816, -0.000372765991423766, -0.000346593395744393, -0.000295691633640415, -0.000226574040709409, -0.000148361321014263, -7.15564876677562e-05, -6.62090849429441e-06, 3.74852686962217e-05, 5.45450612920505e-05, 4.20006171717866e-05, 1.35401648427330e-06, -6.19818821816343e-05, -0.000139367119828060, -0.000220086428473569, -0.000292794894111472, -0.000347077784180089, -0.000374903618874280, -0.000371767818861330, -0.000337368713935819, -0.000275708221832627, -0.000194604598020111, -0.000104665332035711, -1.78656036341389e-05, 5.40909203373907e-05, 0.000101389110781792, 0.000117490495628499, 0.000100079331888557, 5.14485996668415e-05, -2.17542565843796e-05, -0.000109378340861614, -0.000199126927197707, -0.000278220645918136, -0.000335161688052507, -0.000361335317734334, -0.000352247901877521, -0.000308201879606840, -0.000234327175788325, -0.000139934858428603, -3.72974436075021e-05, 6.00108688487802e-05, 0.000138966880722728, 0.000188913158966552, 0.000203055320505069, 0.000179463473091998, 0.000121402810310388, 3.69606340130003e-05, -6.20130938044368e-05, -0.000161475510793451, -0.000247116882168742, -0.000306323849209745, -0.000329950853889350, -0.000313633105695290, -0.000258454717355816, -0.000170876720334370, -6.19189970330990e-05, 5.43004407579393e-05, 0.000162472064212700, 0.000248196855046975, 0.000299986019049041, 0.000310892118519326, 0.000279529283026230, 0.000210345304206706, 0.000113083089959420, 1.51102300500786e-06, -0.000108429652120519, -0.000200793524233981, -0.000261840107303159, -0.000281959218267758, -0.000257060823678710, -0.000189210837313325, -8.64348948833822e-05, 3.83146731989902e-05, 0.000168876159204019, 0.000288075083992844, 0.000380079584022887, 0.000432611704607827, 0.000438686701922343, 0.000397657235213528, 0.000315382701113963, 0.000203511916424503, 7.79443793352830e-05, -4.33024123813616e-05, -0.000142563431297522, -0.000204967679938101, -0.000220536177939580, -0.000185620288564346, -0.000103503296597557, 1.59748788972540e-05, 0.000157677881761018, 0.000303202676576579, 0.000433376307458838, 0.000530897303209585, 0.000582751783434735, 0.000582070961708282, 0.000529160529565945, 0.000431555817302920, 0.000303072467975476, 0.000161982724396093, 2.85446555197459e-05, -7.77694878007941e-05, -0.000140979943785106, -0.000150851108080853, -0.000104387032877192, -6.33651642658941e-06, 0.000131356028018731, 0.000291112274745969, 0.000452071738744035, 0.000592937680486477, 0.000694910701108046, 0.000744325557361080, 0.000734602666578306, 0.000667256362958914, 0.000551784840740882, 0.000404465766762847, 0.000246189019906166, 9.96337809522606e-05, -1.38510829347489e-05, -7.72108379041154e-05, -8.01043505303799e-05, -2.04158843689713e-05, 9.53378256609960e-05, 0.000252804516646692, 0.000431673203343131, 0.000608409666394079, 0.000759463182813475, 0.000864532219144668, 0.000909401228809099, 0.000887997301145860, 0.000803324682407034, 0.000667172510637039, 0.000498593606550304, 0.000321365676866416, 0.000160760934070939, 4.00727611782880e-05, -2.26343737364921e-05, -1.70868512745195e-05, 5.76731588647965e-05, 0.000193039084153931, 0.000371903759925864, 0.000570919986227520, 0.000763645123551482, 0.000924162349305985, 0.00103066649238175, 0.00106853727148987, 0.00103244755971902, 0.000927223165903651, 0.000767299563056456, 0.000574852769309671, 0.000376825982356749, 0.000201268656101776, 7.34648776270198e-05, 1.24070859245211e-05, 2.80838117765318e-05, 0.000119988223038953, 0.000277049092627082, 0.000479033873761259, 0.000699224338285094, 0.000908034354943504, 0.00107706003169344, 0.00118302984400820, 0.00121108024333813, 0.00115692409344799, 0.00102757260506499, 0.000840513190842248, 0.000621415607591608, 0.000400695029744950, 0.000209353048818752, 7.47075806938355e-05, 1.65592566966527e-05, 4.43632059770047e-05, 0.000155785664973347, 0.000336881470368418, 0.000563872398433345, 0.000806315469467426, 0.00103122518257270, 0.00120760810451037, 0.00131077073506284, 0.00132581829624860, 0.00124983425549857, 0.00109243861726001, 0.000874610957809410, 0.000625936255313105, 0.000380615346853356, 0.000172797107864505, 3.18487133921495e-05, -2.17619612743013e-05, 2.05848268364167e-05, 0.000154323310786290, 0.000362162289120472, 0.000616322174929743, 0.000882239153522116, 0.00112326616098755, 0.00130571102589181, 0.00140353944281224, 0.00140206653690055, 0.00130013728262755, 0.00111045156157591, 0.000857986758518552, 0.000576690702399243, 0.000304905739487115, 8.01129107708659e-05, -6.62591255630177e-05, -0.000113263171698494, -5.34580578000928e-05, 0.000105882490726803, 0.000343600614650747, 0.000627394921768004, 0.000918157310214902, 0.00117528977090818, 0.00136230786264217, 0.00145193491134169, 0.00142999648194268, 0.00129754266805992, 0.00107090029447945, 0.000779602675056854, 0.000462475403799353, 0.000162378042444864, -7.96701975862397e-05, -0.000230193138480478, -0.000267980979526746, -0.000187185616568431, 1.68001974335223e-06, 0.000272982968855922, 0.000589329473032378, 0.000906583318405811, 0.00117989150629141, 0.00136987610127025, 0.00144815717512730, 0.00140141416062031, 0.00123342740629537, 0.000964767949931643, 0.000630170893161479, 0.000273905488464157, -5.62220857314173e-05, -0.000315444351659155, -0.000468260788451706, -0.000493474070150026, -0.000387301364008206, -0.000164129038854020, 0.000145250768127580, 0.000497683559294464, 0.000843468772579135, 0.00113314729779126, 0.00132435545750713, 0.00138776959259182, 0.00131134294212570, 0.00110218725542805, 0.000785845699370335, 0.000402990733511940, 3.99893459503250e-06, -0.000357898946249736, -0.000633941722333072, -0.000786649163061719, -0.000795150868909707, -0.000658296893927505, -0.000395070421559947, -4.22296438777588e-05, 0.000350549724889680, 0.000727374765813304, 0.00103379317090276, 0.00122434293295465, 0.00126896808290345, 0.00115737667805502, 0.000900732759382961, 0.000530390876692117, 9.38300673746529e-05, -0.000351707027743205, -0.000747000718456762, -0.00103902996157222, -0.00118838751730768, -0.00117492144626228, -0.00100077757638498, -0.000690408127843423, -0.000287481739007326, 0.000150895860672124, 0.000561909040237825, 0.000885643921772900, 0.00107342720509868, 0.00109470921496650, 0.000941545657031790, 0.000630001197809829, 0.000198259144937968, -0.000298366188481954, -0.000794842352360474, -0.00122529580518369, -0.00153210898681887, -0.00167401839223653, -0.00163204482680460, -0.00141243669316950, -0.00104614990695071, -0.000584913053414426, -9.43511518045388e-05, 0.000354898503468669, 0.000696900106497269, 0.000879607902098410, 0.000872272371270114, 0.000669994115522788, 0.000294773557626332, -0.000207156358975237, -0.000771379706388892, -0.00132396020768094, -0.00179153467307714, -0.00211148323207129, -0.00224074760864274, -0.00216207971320742, -0.00188679880591775, -0.00145364465281279, -0.000923807443708452, -0.000372789938556068, 0.000119841772447416, 0.000481410050001135, 0.000656296018872343, 0.000613887282092550, 0.000353193900843299, -9.65777055452965e-05, -0.000679611811681433, -0.00132081842689967, -0.00193593340957792, -0.00244305381697544, -0.00277400898040880, -0.00288401294455681, -0.00275821734320467, -0.00241423245989351, -0.00190017875532595, -0.00128850228247606, -0.000666309853935493, -0.000123542108461458, 0.000259445380735066, 0.000423153934396292, 0.000337516272539388, 6.51935260406833e-06, -0.000531801375283896, -0.00121009333919969, -0.00194053978027269, -0.00262669857397093, -0.00317671465984686, -0.00351612016953454, -0.00359842581229757, -0.00341202090241068, -0.00298234788505944, -0.00236899384037190, -0.00165799588891084, -0.000950369356379730, -0.000348360591246070, 5.86906961540030e-05, 0.000206949579184453, 6.73549805523069e-05, -0.000349755947479551, -0.000995410322438677, -0.00178811307904678, -0.00262457860574440, -0.00339365317561537, -0.00399158056867122, -0.00433649967153816, -0.00438017596642348, -0.00411527461936687, -0.00357711293298644, -0.00283952621553319, -0.00200533937897321, -0.00119264285876185, -0.000518715056287459, -8.37525162164028e-05, 4.33210754626714e-05, -0.000165005415492895, -0.000690251824153313, -0.00146963222596676, -0.00240392191838378, -0.00337050294402915, -0.00423991102010163, -0.00489363471638705, -0.00524075567046367, -0.00523107970288012, -0.00486290067709348, -0.00418419268159001, -0.00328696026171907, -0.00229537012888407, -0.00134920131553110, -0.000584788924821149, -0.000116064897705113, -1.82992625022300e-05, -0.000316867243977766, -0.000982676022288750, -0.00193504604283060, -0.00305178370735433, -0.00418522521742768, -0.00518214103305988, -0.00590485513993063, -0.00625066257680795, -0.00616684676623158, -0.00565910247543792, -0.00479207550717463, -0.00368174452599236, -0.00248053616726380, -0.00135704271614833, -0.000473040844828747, 3.90978709366338e-05, 9.54502803103512e-05, -0.000326650001353890, -0.00118398095980938, -0.00237179374910360, -0.00373680344367305, -0.00509720557746826, -0.00626715471403352, -0.00708240809286751, -0.00742365544916522, -0.00723422324057162, -0.00652959614205454, -0.00539719794137563, -0.00398623341503058, -0.00248869940704612, -0.00111397361677382, -6.02826789660807e-05, 0.000513074788168865, 0.000508925970625818, -9.25088310335550e-05, -0.00122858821543823, -0.00276047032965249, -0.00449003535888870, -0.00618551627484031, -0.00761254896820268, -0.00856655583079061, -0.00890202295035790, -0.00855456878873283, -0.00755252053339462, -0.00601608993969924, -0.00414383659508427, -0.00218788274774973, -0.000420884185504500, 0.000900966300756372, 0.00157398457824694, 0.00147708973392012, 0.000591634027795809, -0.000992141220624823, -0.00308337715750074, -0.00541303330443373, -0.00766793154274235, -0.00953222706031320, -0.0107309083669803, -0.0110694925528476, -0.0104643301274591, -0.00895902502834240, -0.00672413009343370, -0.00403947218781533, -0.00126072230022161, 0.00122592272656971, 0.00305537799170831, 0.00393490552316309, 0.00368804040531499, 0.00228490996844056, -0.000145767272504191, -0.00332555458807025, -0.00685588461384939, -0.0102655120253502, -0.0130704285950772, -0.0148389815811665, -0.0152538418652954, -0.0141624944886200, -0.0116089442806555, -0.00784141570284186, -0.00329359299321063, 0.00145975268217964, 0.00576865237158399, 0.00898826817446636, 0.0105644406152318, 0.0101140543782403, 0.00748996277831231, 0.00282152673027790, -0.00347561788151491, -0.0107235993507144, -0.0180392456536087, -0.0244191027631540, -0.0288441470013709, -0.0303931767335190, -0.0283523583199014, -0.0223083869700669, -0.0122140744867133, 0.00158204364304018, 0.0183467627480377, 0.0370141587650632, 0.0562741699228296, 0.0746893559905620, 0.0908281482690237, 0.103400832862132, 0.111384053152872, 0.114120624226917, 0.111384053152872, 0.103400832862132, 0.0908281482690237, 0.0746893559905620, 0.0562741699228296, 0.0370141587650632, 0.0183467627480377, 0.00158204364304018, -0.0122140744867133, -0.0223083869700669, -0.0283523583199014, -0.0303931767335190, -0.0288441470013709, -0.0244191027631540, -0.0180392456536087, -0.0107235993507144, -0.00347561788151491, 0.00282152673027790, 0.00748996277831231, 0.0101140543782403, 0.0105644406152318, 0.00898826817446636, 0.00576865237158399, 0.00145975268217964, -0.00329359299321063, -0.00784141570284186, -0.0116089442806555, -0.0141624944886200, -0.0152538418652954, -0.0148389815811665, -0.0130704285950772, -0.0102655120253502, -0.00685588461384939, -0.00332555458807025, -0.000145767272504191, 0.00228490996844056, 0.00368804040531499, 0.00393490552316309, 0.00305537799170831, 0.00122592272656971, -0.00126072230022161, -0.00403947218781533, -0.00672413009343370, -0.00895902502834240, -0.0104643301274591, -0.0110694925528476, -0.0107309083669803, -0.00953222706031320, -0.00766793154274235, -0.00541303330443373, -0.00308337715750074, -0.000992141220624823, 0.000591634027795809, 0.00147708973392012, 0.00157398457824694, 0.000900966300756372, -0.000420884185504500, -0.00218788274774973, -0.00414383659508427, -0.00601608993969924, -0.00755252053339462, -0.00855456878873283, -0.00890202295035790, -0.00856655583079061, -0.00761254896820268, -0.00618551627484031, -0.00449003535888870, -0.00276047032965249, -0.00122858821543823, -9.25088310335550e-05, 0.000508925970625818, 0.000513074788168865, -6.02826789660807e-05, -0.00111397361677382, -0.00248869940704612, -0.00398623341503058, -0.00539719794137563, -0.00652959614205454, -0.00723422324057162, -0.00742365544916522, -0.00708240809286751, -0.00626715471403352, -0.00509720557746826, -0.00373680344367305, -0.00237179374910360, -0.00118398095980938, -0.000326650001353890, 9.54502803103512e-05, 3.90978709366338e-05, -0.000473040844828747, -0.00135704271614833, -0.00248053616726380, -0.00368174452599236, -0.00479207550717463, -0.00565910247543792, -0.00616684676623158, -0.00625066257680795, -0.00590485513993063, -0.00518214103305988, -0.00418522521742768, -0.00305178370735433, -0.00193504604283060, -0.000982676022288750, -0.000316867243977766, -1.82992625022300e-05, -0.000116064897705113, -0.000584788924821149, -0.00134920131553110, -0.00229537012888407, -0.00328696026171907, -0.00418419268159001, -0.00486290067709348, -0.00523107970288012, -0.00524075567046367, -0.00489363471638705, -0.00423991102010163, -0.00337050294402915, -0.00240392191838378, -0.00146963222596676, -0.000690251824153313, -0.000165005415492895, 4.33210754626714e-05, -8.37525162164028e-05, -0.000518715056287459, -0.00119264285876185, -0.00200533937897321, -0.00283952621553319, -0.00357711293298644, -0.00411527461936687, -0.00438017596642348, -0.00433649967153816, -0.00399158056867122, -0.00339365317561537, -0.00262457860574440, -0.00178811307904678, -0.000995410322438677, -0.000349755947479551, 6.73549805523069e-05, 0.000206949579184453, 5.86906961540030e-05, -0.000348360591246070, -0.000950369356379730, -0.00165799588891084, -0.00236899384037190, -0.00298234788505944, -0.00341202090241068, -0.00359842581229757, -0.00351612016953454, -0.00317671465984686, -0.00262669857397093, -0.00194053978027269, -0.00121009333919969, -0.000531801375283896, 6.51935260406833e-06, 0.000337516272539388, 0.000423153934396292, 0.000259445380735066, -0.000123542108461458, -0.000666309853935493, -0.00128850228247606, -0.00190017875532595, -0.00241423245989351, -0.00275821734320467, -0.00288401294455681, -0.00277400898040880, -0.00244305381697544, -0.00193593340957792, -0.00132081842689967, -0.000679611811681433, -9.65777055452965e-05, 0.000353193900843299, 0.000613887282092550, 0.000656296018872343, 0.000481410050001135, 0.000119841772447416, -0.000372789938556068, -0.000923807443708452, -0.00145364465281279, -0.00188679880591775, -0.00216207971320742, -0.00224074760864274, -0.00211148323207129, -0.00179153467307714, -0.00132396020768094, -0.000771379706388892, -0.000207156358975237, 0.000294773557626332, 0.000669994115522788, 0.000872272371270114, 0.000879607902098410, 0.000696900106497269, 0.000354898503468669, -9.43511518045388e-05, -0.000584913053414426, -0.00104614990695071, -0.00141243669316950, -0.00163204482680460, -0.00167401839223653, -0.00153210898681887, -0.00122529580518369, -0.000794842352360474, -0.000298366188481954, 0.000198259144937968, 0.000630001197809829, 0.000941545657031790, 0.00109470921496650, 0.00107342720509868, 0.000885643921772900, 0.000561909040237825, 0.000150895860672124, -0.000287481739007326, -0.000690408127843423, -0.00100077757638498, -0.00117492144626228, -0.00118838751730768, -0.00103902996157222, -0.000747000718456762, -0.000351707027743205, 9.38300673746529e-05, 0.000530390876692117, 0.000900732759382961, 0.00115737667805502, 0.00126896808290345, 0.00122434293295465, 0.00103379317090276, 0.000727374765813304, 0.000350549724889680, -4.22296438777588e-05, -0.000395070421559947, -0.000658296893927505, -0.000795150868909707, -0.000786649163061719, -0.000633941722333072, -0.000357898946249736, 3.99893459503250e-06, 0.000402990733511940, 0.000785845699370335, 0.00110218725542805, 0.00131134294212570, 0.00138776959259182, 0.00132435545750713, 0.00113314729779126, 0.000843468772579135, 0.000497683559294464, 0.000145250768127580, -0.000164129038854020, -0.000387301364008206, -0.000493474070150026, -0.000468260788451706, -0.000315444351659155, -5.62220857314173e-05, 0.000273905488464157, 0.000630170893161479, 0.000964767949931643, 0.00123342740629537, 0.00140141416062031, 0.00144815717512730, 0.00136987610127025, 0.00117989150629141, 0.000906583318405811, 0.000589329473032378, 0.000272982968855922, 1.68001974335223e-06, -0.000187185616568431, -0.000267980979526746, -0.000230193138480478, -7.96701975862397e-05, 0.000162378042444864, 0.000462475403799353, 0.000779602675056854, 0.00107090029447945, 0.00129754266805992, 0.00142999648194268, 0.00145193491134169, 0.00136230786264217, 0.00117528977090818, 0.000918157310214902, 0.000627394921768004, 0.000343600614650747, 0.000105882490726803, -5.34580578000928e-05, -0.000113263171698494, -6.62591255630177e-05, 8.01129107708659e-05, 0.000304905739487115, 0.000576690702399243, 0.000857986758518552, 0.00111045156157591, 0.00130013728262755, 0.00140206653690055, 0.00140353944281224, 0.00130571102589181, 0.00112326616098755, 0.000882239153522116, 0.000616322174929743, 0.000362162289120472, 0.000154323310786290, 2.05848268364167e-05, -2.17619612743013e-05, 3.18487133921495e-05, 0.000172797107864505, 0.000380615346853356, 0.000625936255313105, 0.000874610957809410, 0.00109243861726001, 0.00124983425549857, 0.00132581829624860, 0.00131077073506284, 0.00120760810451037, 0.00103122518257270, 0.000806315469467426, 0.000563872398433345, 0.000336881470368418, 0.000155785664973347, 4.43632059770047e-05, 1.65592566966527e-05, 7.47075806938355e-05, 0.000209353048818752, 0.000400695029744950, 0.000621415607591608, 0.000840513190842248, 0.00102757260506499, 0.00115692409344799, 0.00121108024333813, 0.00118302984400820, 0.00107706003169344, 0.000908034354943504, 0.000699224338285094, 0.000479033873761259, 0.000277049092627082, 0.000119988223038953, 2.80838117765318e-05, 1.24070859245211e-05, 7.34648776270198e-05, 0.000201268656101776, 0.000376825982356749, 0.000574852769309671, 0.000767299563056456, 0.000927223165903651, 0.00103244755971902, 0.00106853727148987, 0.00103066649238175, 0.000924162349305985, 0.000763645123551482, 0.000570919986227520, 0.000371903759925864, 0.000193039084153931, 5.76731588647965e-05, -1.70868512745195e-05, -2.26343737364921e-05, 4.00727611782880e-05, 0.000160760934070939, 0.000321365676866416, 0.000498593606550304, 0.000667172510637039, 0.000803324682407034, 0.000887997301145860, 0.000909401228809099, 0.000864532219144668, 0.000759463182813475, 0.000608409666394079, 0.000431673203343131, 0.000252804516646692, 9.53378256609960e-05, -2.04158843689713e-05, -8.01043505303799e-05, -7.72108379041154e-05, -1.38510829347489e-05, 9.96337809522606e-05, 0.000246189019906166, 0.000404465766762847, 0.000551784840740882, 0.000667256362958914, 0.000734602666578306, 0.000744325557361080, 0.000694910701108046, 0.000592937680486477, 0.000452071738744035, 0.000291112274745969, 0.000131356028018731, -6.33651642658941e-06, -0.000104387032877192, -0.000150851108080853, -0.000140979943785106, -7.77694878007941e-05, 2.85446555197459e-05, 0.000161982724396093, 0.000303072467975476, 0.000431555817302920, 0.000529160529565945, 0.000582070961708282, 0.000582751783434735, 0.000530897303209585, 0.000433376307458838, 0.000303202676576579, 0.000157677881761018, 1.59748788972540e-05, -0.000103503296597557, -0.000185620288564346, -0.000220536177939580, -0.000204967679938101, -0.000142563431297522, -4.33024123813616e-05, 7.79443793352830e-05, 0.000203511916424503, 0.000315382701113963, 0.000397657235213528, 0.000438686701922343, 0.000432611704607827, 0.000380079584022887, 0.000288075083992844, 0.000168876159204019, 3.83146731989902e-05, -8.64348948833822e-05, -0.000189210837313325, -0.000257060823678710, -0.000281959218267758, -0.000261840107303159, -0.000200793524233981, -0.000108429652120519, 1.51102300500786e-06, 0.000113083089959420, 0.000210345304206706, 0.000279529283026230, 0.000310892118519326, 0.000299986019049041, 0.000248196855046975, 0.000162472064212700, 5.43004407579393e-05, -6.19189970330990e-05, -0.000170876720334370, -0.000258454717355816, -0.000313633105695290, -0.000329950853889350, -0.000306323849209745, -0.000247116882168742, -0.000161475510793451, -6.20130938044368e-05, 3.69606340130003e-05, 0.000121402810310388, 0.000179463473091998, 0.000203055320505069, 0.000188913158966552, 0.000138966880722728, 6.00108688487802e-05, -3.72974436075021e-05, -0.000139934858428603, -0.000234327175788325, -0.000308201879606840, -0.000352247901877521, -0.000361335317734334, -0.000335161688052507, -0.000278220645918136, -0.000199126927197707, -0.000109378340861614, -2.17542565843796e-05, 5.14485996668415e-05, 0.000100079331888557, 0.000117490495628499, 0.000101389110781792, 5.40909203373907e-05, -1.78656036341389e-05, -0.000104665332035711, -0.000194604598020111, -0.000275708221832627, -0.000337368713935819, -0.000371767818861330, -0.000374903618874280, -0.000347077784180089, -0.000292794894111472, -0.000220086428473569, -0.000139367119828060, -6.19818821816343e-05, 1.35401648427330e-06, 4.20006171717866e-05, 5.45450612920505e-05, 3.74852686962217e-05, -6.62090849429441e-06, -7.15564876677562e-05, -0.000148361321014263, -0.000226574040709409, -0.000295691633640415, -0.000346593395744393, -0.000372765991423766, -0.000371143828990816, -0.000342485297930006, -0.000291205174077100, -0.000224724379471763, -0.000152409419307943, -8.42765307013823e-05, -2.96124316508882e-05, 4.27359563634318e-06, 1.30195358555482e-05, -4.24647563137697e-06, -4.48344575877782e-05, -0.000102917195730211, -0.000170365025562497, -0.000237892289803654, -0.000296333745328554, -0.000337893539468504, -0.000357180130205678, -0.000351907719801929, -0.000323155992060342, -0.000275176142504607, -0.000214759899196551, -0.000150280040234256, -9.05251787859542e-05, -4.35009442826526e-05, -1.53517033736746e-05, -9.55499119629498e-06, -2.64892382868700e-05, -6.34298179693306e-05, -0.000114970969442428, -0.000173796326250942, -0.000231714037984559, -0.000280770008237615, -0.000314337010183019, -0.000327993797126448, -0.000320078473574568, -0.000291892905660510, -0.000247460409030712, -0.000192944853870151, -0.000135775521151931, -8.36250450795108e-05, -4.33518875070623e-05, -2.00902358579179e-05, -1.65748909128861e-05, -3.28142751672934e-05, -6.61245603834870e-05, -0.000111544576430454, -0.000162541576769853, -0.000211929405301880, -0.000252848593193085, -0.000279698323161388, -0.000288872187396555, -0.000279221780616026, -0.000252167179506565, -0.000211466481748968, -0.000162663334706720, -0.000112310184268446, -6.70583967549565e-05, -3.27572928598435e-05, -1.36687079690515e-05, -1.19182902273736e-05, -2.72394560893955e-05, -5.70517384690742e-05, -9.68473814575550e-05, -0.000140836174312898, -0.000182751984191670, -0.000216711191948205, -0.000238006886056999, -0.000243723775900697, -0.000233112830152265, -0.000207640076867084, -0.000170775987070716, -0.000127463324843792, -8.34392755369214e-05, -4.44483573110374e-05, -1.54387457896716e-05, 6.89974224852674e-08, 4.48390846925062e-07, -1.38485241123716e-05, -4.03804829973491e-05, -7.50948676537967e-05, -0.000112894524725543, -0.000148352207236388, -0.000176445617716202, -0.000193241341498850, -0.000196402131357741, -0.000185481193813108, -0.000161943673850021, -0.000128942310692718, -9.08563492744216e-05, -5.26820818136178e-05, -1.93382759070846e-05, 4.99396525712985e-06, 1.74291366788252e-05, 1.67407793106498e-05, 3.50315617803419e-06, -2.00213778873869e-05, -5.02146052065163e-05, -8.26205757416121e-05, -0.000112561010433072, -0.000135775793401282, -0.000148990441494891, -0.000150343558612554, -0.000139613954709824, -0.000118221883532868, -8.90092244647987e-05, -5.58260758494103e-05, -2.29972452974647e-05, 5.28389555030305e-06, 2.54961505010855e-05, 3.52981070679250e-05, 3.37660961651943e-05, 2.15469672608618e-05, 7.23746795272482e-07, -2.55142529896370e-05, -5.32855901105837e-05, -7.85765153187353e-05, -9.77822816313704e-05, -0.000108195509658728, -0.000108339992244031, -9.81606287047804e-05, -7.90004021132727e-05, -5.34027390304918e-05, -2.47343931280551e-05, 3.27772934680794e-06, 2.70633563780013e-05, 4.36805555605361e-05, 5.12095937685197e-05, 4.89897614119904e-05, 3.76930612825050e-05, 1.92027265469786e-05, -3.65824575202301e-06, -2.75306433932657e-05, -4.89773592885346e-05, -6.49535468335046e-05, -7.32084427297287e-05, -7.25804047088175e-05, -6.31321800854717e-05, -4.61236155795391e-05, -2.38174205220706e-05, 8.43119069287522e-07, 2.46439352867134e-05, 4.45396499136897e-05, 5.80606492765233e-05, 6.36410056284099e-05, 6.08100022993460e-05, 5.02463067480140e-05, 3.36502590583024e-05, 1.35330238338318e-05, -7.21426288533426e-06, -2.55882629228275e-05, -3.90290549970413e-05, -4.56631460603750e-05, -4.45452849688659e-05, -3.58286655851685e-05, -2.06892397783733e-05, -1.15718801963570e-06, 2.01816895353178e-05, 4.05197220782586e-05, 5.72241611661594e-05, 6.81834244175913e-05, 7.20993778931555e-05, 6.86374216881549e-05, 5.84659873641117e-05, 4.31430424185021e-05, 2.49062438268540e-05, 6.35604391059514e-06, -9.89225641009268e-06, -2.15710707875482e-05, -2.70562042819254e-05, -2.55848978527061e-05, -1.73416653639437e-05, -3.42872766388902e-06, 1.42952682713769e-05, 3.34662423243267e-05, 5.15389284412098e-05, 6.61268020961053e-05, 7.53241608332524e-05, 7.79573934769908e-05, 7.37382509553564e-05, 6.32988878999027e-05, 4.81006125089142e-05, 3.02417074753783e-05, 1.21705236068999e-05, -3.62799702821184e-06, -1.49763353864476e-05, -2.02672709683160e-05, -1.87404866689510e-05, -1.03943319642062e-05, 3.58404452313536e-06, 2.15880852311731e-05, 4.12686580912749e-05, 6.00067448127893e-05, 7.53392372518753e-05, 8.51892241452302e-05, 8.81445625094016e-05, 8.36103258691585e-05, 7.19403366627801e-05, 5.43887830023354e-05, 3.29950927553473e-05, 1.03184022118271e-05, -1.08383547840727e-05, -2.77716078061957e-05, -3.81593840161193e-05, -4.03412877224400e-05, -3.34844315967768e-05, -1.76965961254198e-05, 6.00374585929518e-06, 3.57814289702832e-05, 6.92039315241304e-05, 0.000103484385828821, 0.000135789425416030, 0.000163505341911061, 0.000184502672153669, 0.000197305593707142, 0.000201218316150325, 0.000196333303102994, 0.000183491740843345, 0.000164139032796616, 0.000140160761904866, 0.000113656608320366, 8.67428160834360e-05, 6.13435329217216e-05, 3.90557623958455e-05, 2.10398451631984e-05, 8.00629085771220e-06, 2.38303222087342e-07, -5.41775027494366e-05 };
        //send Cmd 
      

        //hold the filtered data
        private double filtered;

        //hold the replayed raw data
        private List<short> loadedList;
        private int loadedIndex;
        private double filteredLoadedData;
        private double[] loadedDataBuffer;
        private double[] loadedDataBuffer_600;
        private List<double> tempLoadedDataBuffer;
        private int bufferCounter_loadedRaw;

        //hold the raw data in a continuously updating buffer
        private double[] eegBuffer;
        private double[] tempeegBuffer;

        private double[] eegBuffer_600;
        private double[] tempeegBuffer_600;

        //counter to track when we should plot
        private int bufferCounter_raw;

        ///////////////////////////////////////////////////////////////////////smooth_raw_variebles///////////////////////////////////////////////////////////////////////
        private int[] y1; // 1st buffer
        private int[] y3; // 2nd buffer
        private int[] y5; // 3rd buffer
        private int[] y7; // 4th buffer
        private int[] y9; // 5th buffer

        private int n1, n3, n5, n7, n9; // size of 1st, 2nd, 3rd, 4th, and 5th buffers 

        private int m1, m3, m5, m7, m9; // average size of 1st, 2nd, 3rd, 4th, and 5th buffers

        private int thre1, thre3, thre5, thre7, thre9; //threshold of 1st, 2nd, 3rd, 4th, and 5th buffers 

        private int iy1;
        private int iy2;

        private int p;  // output data counter
        private int np;  // input data counter

        private double xi;

        private double step;

        private int[] xb; // signal buffer
        private int[] bb; // correction buffer

        private int end_xb; //size of xb;
        private int mid_xb; // middle point of one powerline period

        private int[] yb; // buffer for smooth data in notch
        private int n_yb;

        private int M; // threshold for linear criterion

        private int N; // integer multiple of (re-sample frequency) / (powerline frequency)

        private int fpl; //powerline frequency
        private int fs; // original sampling frequency
        private int rfs; // sample frequency

        private int[] s; // buffer for average
        private int bufferSize;
        private int D;
        private int N1;

        private int filteredRui;
        private int resampled;
        private int notched;
        private int bw;
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        private ushort RR_Interval = 0;
        private byte RR_Interval_Lo;
        private byte RR_Interval_Hi;
        private int SampleCount = 0;
     

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate void ProgressCallback(int value);

        [DllImport("resampler.dll")]
        public static extern void nskECGreSamplerInit(int from_sampleRate, int to_sampleRate);

        [DllImport("resampler.dll")]
        static extern int nskECGreSampler(int ECGsample, [MarshalAs(UnmanagedType.FunctionPtr)] ProgressCallback callbackPointer);
     


        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main() {
            Application.Run(new Launcher());
           
        }
        
        public Launcher() {

         
            mainForm = new MainForm();
            Complex = new complex[512];
            fft_amp = new double[512];
            for (int n = 0; n < 512; n++)
            {
                Complex[n] = new complex();
            }
            fft = new complex();

            tgHRV = new TGHrv();
            respRate = new RespiratoryRate();
            identificationRecordingGUI = new RecognitionRecordingGUI();
            connector = new Connector();
            connector.DeviceConnected += new EventHandler(OnDeviceConnected);
            connector.DeviceFound += new EventHandler(OnDeviceFound);
            connector.DeviceNotFound += new EventHandler(OnDeviceNotFound);
            connector.DeviceConnectFail += new EventHandler(OnDeviceNotFound);
            connector.DeviceDisconnected += new EventHandler(OnDeviceDisconnected);
            connector.DeviceValidating += new EventHandler(OnDeviceValidating);
            Connector.EKGPersonalizationEvent += new EventHandler(OnEKGPersonalizationEvent);
            

            mainForm.ConnectButtonClicked += new EventHandler(OnConnectButtonClicked);
            mainForm.DisconnectButtonClicked += new EventHandler(OnDisconnectButtonClicked);
            mainForm.ConfirmHeartAgeButtonClicked += new EventHandler(OnConfirmHeartAgeButtonClicked);
            mainForm.IdentificationButtonClicked += new EventHandler(OnIdentificationButtonClicked);
            mainForm.NewUserButtonClicked += new EventHandler(OnNewUserButtonClicked);
            mainForm.Disposed += new EventHandler(OnMainFormDisposed);
            mainForm.ReplyButtonClicked += new EventHandler(OnReplayButtonClicked);
            mainForm.StopReplayButtonClicked += new EventHandler(OnStopReplayButtonClicked);
            mainForm.sendUARTOpenCmdByteEvent += new deleupdateUARTCmdToBMD(setUARTOpenCmdByte);
            mainForm.sendUARTCloseCmdByteEvent += new deleupdateUARTCmdToBMD(setUARTCloseCmdByte);
            mainForm.sendSPIOpenCmdEvent += new deleupdateSPICmdToBMD(setSPIOpenCmdByte);
            mainForm.sendSPICloseCmdEvent += new deleupdateSPICmdToBMD(setSPICloseCmdByte);
            mainForm.sendI2COpenCmdEvent += new deleupdateI2CCmdToBMD(setI2COpenCmdByte);
            mainForm.sendI2CCloseCmdEvent += new deleupdateI2CCmdToBMD(setI2CCloseCmdByte);
            mainForm.sendUARTWriteDateEvent += new deleupdateUARTWriteDateTOBMD(setUARTWriteCmdByte);
            mainForm.sendSPI_I2CWriteDateEvent += new deleupdateSPI_I2CWriteDateTOBMD(setSPI_I2CWriteCmdByte);
            mainForm.sendClockFrequencyWriteDateEvent += new deleupdateClockFrequencyTOBMD(setClockFrequencyWriteCmdByte);
            mainForm.sendSamplingRate300CmdEvent += new deleupdateSamplingRateToBMD(setSamplingRate300CmdByte);
            mainForm.sendSamplingRate600CmdEvent += new deleupdateSamplingRateToBMD(setSamplingRate600CmdByte);
            mainForm.UARTReadFromBMDEVENT += new deleupdateUARTReadFromBMD(SetUartReadCmdByte);
            mainForm.SPIReadFromBMDEVENT += new deleupdateReadSPICmdFromBMD(SetSpiReadCmdByte);
            mainForm.TrimByteReadFromBMDEVENT += new deleupdateReadTrimByteFromBMD(SetTrimByteReadCmdByte);
            mainForm.efuseProgramEvent += new deleefuseProgram(seteFuseByte);

            InitializeComponent();
            ResetRui();

            rawCounter = 0;     //initially zero
            //delay = 512 * 5;    //5 seconds delay
            delay = 0;  //no delay (although there is still a delay due to the filtering of data)


            FFT_RAW = 0;
            FFT_buffer = new double[600];
            sample_Before=new double[600];
         
            //hold the raw data in a continuously updating buffer
            eegBuffer = new double[bufferSize_hp];
            tempeegBuffer = new double[bufferSize_hp];

            loadedDataBuffer = new double[bufferSize_hp];
            tempLoadedDataBuffer = new List<double>();

            eegBuffer_600 = new double[bufferSize_hp_600];
            tempeegBuffer_600 = new double[bufferSize_hp_600];

            loadedDataBuffer_600 = new double[bufferSize_hp_600];
            tempLoadedDataBuffer = new List<double>();

            //counter to track when we should plot
            bufferCounter_raw = 0;

            bufferCounter_loadedRaw = 0;
        }


        
        //accept heart age input parameters from mainForm then calculate
        void OnConfirmHeartAgeButtonClicked(object sender, EventArgs e)
        {

            HeartAgeEventArgs heartAgeEventArgs = (HeartAgeEventArgs)e;   //cast this as a HeartAgeEventArgs
            string heartAgeFileName = heartAgeEventArgs.parametersFileName;     //get the filename
            int heartAge = heartAgeEventArgs.parametersAge;  //get the heart age
            connector.GetHeartAge(heartAge, heartAgeFileName);
        }
        //accept the order of identification from mainForm
        void OnIdentificationButtonClicked(object sender, EventArgs e)
        {
            //start identification
            connector.EKGstartDetection();
        }

   
        //accept the order of training from mainForm
        void OnNewUserButtonClicked(object sender, EventArgs e)
        { 
            //get the username from addNewUserGUI
            NewUserNameEventArgs newAddUserNameEventArgs = (NewUserNameEventArgs)e;
            string newUserName = newAddUserNameEventArgs.parametersUserName; //get new user name
            connector.EKGstartLongTraining(newUserName); // start training process
            //Console.WriteLine("new user name: " + newUserName);
        }

        //replay EKG from saved file
        void OnReplayButtonClicked(object sender, EventArgs e)
        {
            mainForm.Replay.Visible = false;
            mainForm.stopReplay.Visible = true;
            loadedList = new List<short>();
            captureData(mainForm.loadedFileData, loadedList);
            //Console.WriteLine("loaded size: " + loadedList.Count);
            //clear graph
            mainForm.rawGraphPanel.LineGraph.Clear();
            loadedIndex = 0;

        }

        //plot one raw data
        private void timerPlot(object sender, EventArgs e)
        {
            
            if (loadedIndex < loadedList.Count)
            {
                plotCapturedData(loadedList[loadedIndex]);
                loadedIndex++;
            }
            
        }
        private void button1_Click(object sender, EventArgs e) {
            //UpdateConnectButton(true);
            //UpdateStatusLabel("Searching for MindSet...");

            //mainForm.updateConnectButton(true);
            //mainForm.updateStatusLabel("Searching for MindSet...");

            //Comment this line out if you want the splash screen to wait for good connection.
            UpdateVisibility(false);

            //connector.RefreshAvailableConnections();

        }

        void OnDeviceNotFound(object sender, EventArgs e) {
            UpdateConnectButton(false);
            mainForm.updateConnectButton(false);
            mainForm.updateStatusLabel("Unable to connect.");
        }

        void OnDeviceFound(object sender, EventArgs e) {
            Connector.PortEventArgs de = (Connector.PortEventArgs)e;

            string tempPortName = de.PortName;
            mainForm.updateStatusLabel("Device found on " + tempPortName + ". Connecting...");

            connector.Connect(tempPortName);

        }

        void OnDeviceValidating(object sender, EventArgs e) {
            Connector.ConnectionEventArgs ce = (Connector.ConnectionEventArgs)e;

            mainForm.updateStatusLabel("Validating " + ce.Connection.PortName + ".");
        }
        //get message from algo, then transfer it to mainform
        void OnEKGPersonalizationEvent(object sender, EventArgs e)
        {

            EKGPersonalizationEventArgs ekgArgs = (EKGPersonalizationEventArgs)(e);
            int status = ekgArgs.statusMessage;

            switch (status)
            {
                case 268:
                    string data = (string)(ekgArgs.dataMessage);
                    Console.WriteLine("Handler Message: status = MSG_EKG_IDENTIFIED " + " and username = " + data);
                    //update result
                    mainForm.identificationGUI.updateIdentificationResultIndicator(data);
                    //stop
                    //connector.EKGstopDetection();
                    
                    break;

                case 269:
                    Console.WriteLine("Handler Message: status = MSG_EKG_TRAINED");

                    //connector.EKGstopTraining();
                    //mainForm.updateTrainingStepIndicator((string)ekgArgs.dataMessage);
                    mainForm.identificationRecordingGUI.updateTrainingStepIndicator("MSG_EKG_TRAINED");
                    //connector.EKGstartDetection();

                    break;

                case 270:
                    int trainStep = (int)ekgArgs.dataMessage;
                    Console.WriteLine("Handler Message: status = MSG_EKG_TRAIN_STEP " + " and training step = " + trainStep);
                    //update training step status
                    mainForm.identificationRecordingGUI.updateTrainingStepIndicator(trainStep.ToString());
                    break;
                case 271:
                    Console.WriteLine("Handler Message: status = MSG_EKG_TRAIN_TOUCH");
                    //if wait for 2 seconds, tell user to touch sensors again
                    mainForm.identificationRecordingGUI.updateTrainingStepIndicator("MSG_EKG_TRAIN_TOUCH");
                    break;
            }
        }

        void OnDeviceConnected(object sender, EventArgs e) {
            Connector.DeviceEventArgs de = (Connector.DeviceEventArgs)e;

            //save the device
            device = de.Device;

            mainForm.updateStatusLabel("Connected to a device on " + de.Device.PortName + ".");

            de.Device.DataReceived += new EventHandler(OnDataReceived);
            mainForm.updateConnectButton(true);
            
            UpdateVisibility(false);
            Console.WriteLine("Done");
        }

        void OnDeviceDisconnected(object sender, EventArgs e) {
            Connector.DeviceEventArgs de = (Connector.DeviceEventArgs)e;

            mainForm.updateStatusLabel("Disconnected from a device on " + de.Device.PortName + ".");

            mainForm.updateConnectButton(false);

        }

        

        void OnDataReceived(object sender, EventArgs e) {
            Device d = (Device)sender;
            Device.DataEventArgs de = (Device.DataEventArgs)e;
            ProgressCallback callback =
             (value) =>
             {

             sample_After[SampleCount++] = value;
             if (SampleCount >= 512)
                 SampleCount = 0;
          //   Console.WriteLine("reSample ECG = {0}", value);
          //   Console.WriteLine("sample_After value is :" + sample_After[SampleCount-1]);
            };


            //

            ThinkGear.DataRow[] tempDataRowArray = de.DataRowArray;

            TGParser thinkGearParser = new TGParser();
            thinkGearParser.Read(de.DataRowArray);

        //    connector.Send(device.PortName, bytesToSend);

            // Pass off data for recording
            if(mainForm.recordFlag == true) {
                //save the datalog.txt
                mainForm.recordData(de.DataRowArray);
            }

            /* Loop through new parsed data */
            for(int i = 0; i < thinkGearParser.ParsedData.Length; i++) {
                
                //save the poorsignal value. this is always updated
                if(thinkGearParser.ParsedData[i].ContainsKey("PoorSignal")) {
                    mainForm.poorQuality = thinkGearParser.ParsedData[i]["PoorSignal"];
                    mainForm.updateSignal_QualityBox(thinkGearParser.ParsedData[i]["PoorSignal"].ToString());
                    //mainForm.(thinkGearParser.ParsedData[i]["PoorSignal"].ToString());
                    mainForm.identificationRecordingGUI.poorSignal = thinkGearParser.ParsedData[i]["PoorSignal"];
                    
                }

                    
                //update heart age
                if (thinkGearParser.ParsedData[i].ContainsKey("HeartAge"))
                {
                    mainForm.updateHeartAgeIndicator((thinkGearParser.ParsedData[i]["HeartAge"]).ToString());
                    Console.WriteLine("HeartAge = " + thinkGearParser.ParsedData[i]["HeartAge"]);
                }

                //update Trim Byte
                if (thinkGearParser.ParsedData[i].ContainsKey("EGOTrim")) {
                    mainForm.TrimByte = (byte)thinkGearParser.ParsedData[i]["EGOTrim"];
                    //mainForm.updateTrim_ByteBox(thinkGearParser.ParsedData[i]["EGOTrim"].ToString());
                    string trimbyte_hex; ;
                    if ((byte)thinkGearParser.ParsedData[i]["EGOTrim"] <= 0x0F)
                    {
                        trimbyte_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGOTrim"]);
                        trimbyte_hex = "0" + trimbyte_hex;
                    }
                    else
                    {
                        trimbyte_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGOTrim"]);
                    }
                    mainForm.updateTrim_ByteBox(trimbyte_hex);
                }

                //update UART conOut bytes
                if (thinkGearParser.ParsedData[i].ContainsKey("EGODebug1Data7"))
                {
                    string textBox8_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGODebug1Data7"] <= 0x0F)
                    {
                        textBox8_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data7"]);
                        textBox8_hex = "0x0" + textBox8_hex;
                    }
                    else
                    {
                        textBox8_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data7"]);
                        textBox8_hex = "0x" + textBox8_hex;
                    }
                    mainForm.updateconOut7Box(textBox8_hex);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("EGODebug1Data6"))
                {
                    string textBox7_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGODebug1Data6"] <= 0x0F)
                    {
                        textBox7_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data6"]);
                        textBox7_hex = "0x0" + textBox7_hex;
                    }
                    else
                    {
                        textBox7_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data6"]);
                        textBox7_hex = "0x" + textBox7_hex;
                    }
                    mainForm.updateconOut6Box(textBox7_hex);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("EGODebug1Data5"))
                {
                    string textBox6_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGODebug1Data5"] <= 0x0F)
                    {
                        textBox6_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data5"]);
                        textBox6_hex = "0x0" + textBox6_hex;
                    }
                    else
                    {
                        textBox6_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data5"]);
                        textBox6_hex = "0x" + textBox6_hex;
                    }
                    mainForm.updateconOut5Box(textBox6_hex);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("EGODebug1Data4"))
                {
                    string textBox5_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGODebug1Data4"] <= 0x0F)
                    {
                        textBox5_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data4"]);
                        textBox5_hex = "0x0" + textBox5_hex;
                    }
                    else
                    {
                        textBox5_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data4"]);
                        textBox5_hex = "0x" + textBox5_hex;
                    }
                    mainForm.updateconOut4Box(textBox5_hex);

                    byte trim_byte_0;
                    string trim_byte_0_str;

                    trim_byte_0 = (byte)thinkGearParser.ParsedData[i]["EGODebug1Data4"];
                    trim_byte_0 &= 0x1F;
                    if (trim_byte_0 <= 0x0F)
                    {
                        trim_byte_0_str = String.Format("{0:X}", trim_byte_0);
                        trim_byte_0_str = "0" + trim_byte_0_str;
                    }
                    else
                    {
                        trim_byte_0_str = String.Format("{0:X}", trim_byte_0);
                    }

                    mainForm.updateTrim_Byte_0Box(trim_byte_0_str);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("EGOTrim"))
                {
                    string textBox4_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGOTrim"] <= 0x0F)
                    {
                        textBox4_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGOTrim"]);
                        textBox4_hex = "0x0" + textBox4_hex;
                    }
                    else
                    {
                        textBox4_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGOTrim"]);
                        textBox4_hex = "0x" + textBox4_hex;
                    }
                    mainForm.updateconOut3Box(textBox4_hex);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("EGODebug1Data2"))
                {
                    string textBox3_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGODebug1Data2"] <= 0x0F)
                    {
                        textBox3_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data2"]);
                        textBox3_hex = "0x0" + textBox3_hex;
                    }
                    else
                    {
                        textBox3_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data2"]);
                        textBox3_hex = "0x" + textBox3_hex;
                    }
                    mainForm.updateconOut2Box(textBox3_hex);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("EGODebug1Data1"))
                {
                    string textBox2_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGODebug1Data1"] <= 0x0F)
                    {
                        textBox2_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data1"]);
                        textBox2_hex = "0x0" + textBox2_hex;
                    }
                    else
                    {
                        textBox2_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data1"]);
                        textBox2_hex = "0x" + textBox2_hex;
                    }
                    mainForm.updateconOut1Box(textBox2_hex);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("EGODebug1Data0"))
                {
                    string textBox1_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["EGODebug1Data0"] <= 0x0F)
                    {
                        textBox1_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data0"]);
                        textBox1_hex = "0x0" + textBox1_hex;
                    }
                    else
                    {
                        textBox1_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["EGODebug1Data0"]);
                        textBox1_hex = "0x" + textBox1_hex;
                    }
                    mainForm.updateconOut0Box(textBox1_hex);
                }

                //update SPI/I2C registers
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config0"))
                {
                    string RegisterBox_hex0;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config0"] <= 0x0F)
                    {
                        RegisterBox_hex0 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config0"]);
                        RegisterBox_hex0 = "0x0" + RegisterBox_hex0;
                    }
                    else
                    {
                        RegisterBox_hex0 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config0"]);
                        RegisterBox_hex0 = "0x" + RegisterBox_hex0;
                    }
                    mainForm.updateSPI_I2CRegisterBox0(RegisterBox_hex0);
                    //Console.WriteLine("Config0 is " + RegisterBox_hex0);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config1"))
                {
                    string RegisterBox_hex1;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config1"] <= 0x0F)
                    {
                        RegisterBox_hex1 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config1"]);
                        RegisterBox_hex1 = "0x0" + RegisterBox_hex1;
                    }
                    else
                    {
                        RegisterBox_hex1 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config1"]);
                        RegisterBox_hex1 = "0x" + RegisterBox_hex1;
                    }
                    mainForm.updateSPI_I2CRegisterBox1(RegisterBox_hex1);
                    //Console.WriteLine("Config1 is " + RegisterBox_hex1);

                    byte trim_byte_0;
                    string trim_byte_0_str;

                    trim_byte_0 = (byte)thinkGearParser.ParsedData[i]["BMD200Config1"];
                    trim_byte_0 &= 0x1F;
                    if (trim_byte_0 <= 0x0F)
                    {
                        trim_byte_0_str = String.Format("{0:X}", trim_byte_0);
                        trim_byte_0_str = "0" + trim_byte_0_str;
                    }
                    else
                    {
                        trim_byte_0_str = String.Format("{0:X}", trim_byte_0);
                    }

                    mainForm.updateTrim_Byte_0Box(trim_byte_0_str);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config2"))
                {
                    string RegisterBox_hex2;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config2"] <= 0x0F)
                    {
                        RegisterBox_hex2 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config2"]);
                        RegisterBox_hex2 = "0x0" + RegisterBox_hex2;
                    }
                    else
                    {
                        RegisterBox_hex2 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config2"]);
                        RegisterBox_hex2 = "0x" + RegisterBox_hex2;
                    }
                    mainForm.updateSPI_I2CRegisterBox2(RegisterBox_hex2);
                    //Console.WriteLine("Config2 is " + RegisterBox_hex2);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config3"))
                {
                    string RegisterBox_hex3;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config3"] <= 0x0F)
                    {
                        RegisterBox_hex3 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config3"]);
                        RegisterBox_hex3 = "0x0" + RegisterBox_hex3;
                    }
                    else
                    {
                        RegisterBox_hex3 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config3"]);
                        RegisterBox_hex3 = "0x" + RegisterBox_hex3;
                    }
                    mainForm.updateSPI_I2CRegisterBox3(RegisterBox_hex3);
                    //Console.WriteLine("Config3 is " + RegisterBox_hex3);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config4"))
                {
                    string RegisterBox_hex4;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config4"] <= 0x0F)
                    {
                        RegisterBox_hex4 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config4"]);
                        RegisterBox_hex4 = "0x0" + RegisterBox_hex4;
                    }
                    else
                    {
                        RegisterBox_hex4 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config4"]);
                        RegisterBox_hex4 = "0x" + RegisterBox_hex4;
                    }
                    mainForm.updateSPI_I2CRegisterBox4(RegisterBox_hex4);
                    //Console.WriteLine("Config4 is " + RegisterBox_hex4);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config5"))
                {
                    string RegisterBox_hex5;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config5"] <= 0x0F)
                    {
                        RegisterBox_hex5 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config5"]);
                        RegisterBox_hex5 = "0x0" + RegisterBox_hex5;
                    }
                    else
                    {
                        RegisterBox_hex5 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config5"]);
                        RegisterBox_hex5 = "0x" + RegisterBox_hex5;
                    }
                    mainForm.updateSPI_I2CRegisterBox5(RegisterBox_hex5);
                    //Console.WriteLine("Config5 is " + RegisterBox_hex5);

                    string trimbyte_hex;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config5"] <= 0x0F)
                    {
                        trimbyte_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config5"]);
                        trimbyte_hex = "0" + trimbyte_hex;
                    }
                    else
                    {
                        trimbyte_hex = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config5"]);
                    }
                    mainForm.updateTrim_ByteBox(trimbyte_hex);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config6"))
                {
                    string RegisterBox_hex6;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config6"] <= 0x0F)
                    {
                        RegisterBox_hex6 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config6"]);
                        RegisterBox_hex6 = "0x0" + RegisterBox_hex6;
                    }
                    else
                    {
                        RegisterBox_hex6 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config6"]);
                        RegisterBox_hex6 = "0x" + RegisterBox_hex6;
                    }
                    mainForm.updateSPI_I2CRegisterBox6(RegisterBox_hex6);
                    //Console.WriteLine("Config6 is " + RegisterBox_hex6);

                    string HR_str;
                    HR_str = String.Format("{0:D}", (byte)thinkGearParser.ParsedData[i]["BMD200Config6"]);
                    mainForm.updateHBRBox(HR_str);

                }

                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config7"))
                {
                    string RegisterBox_hex7;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config7"] <= 0x0F)
                    {
                        RegisterBox_hex7 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config7"]);
                        RegisterBox_hex7 = "0x0" + RegisterBox_hex7;
                    }
                    else
                    {
                        RegisterBox_hex7 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config7"]);
                        RegisterBox_hex7 = "0x" + RegisterBox_hex7;
                    }
                    mainForm.updateSPI_I2CRegisterBox7(RegisterBox_hex7);
                    //Console.WriteLine("Config7 is " + RegisterBox_hex7);
                    RR_Interval_Lo = (byte)thinkGearParser.ParsedData[i]["BMD200Config7"];
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config8"))
                {
                    string RegisterBox_hex8;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config8"] <= 0x0F)
                    {
                        RegisterBox_hex8 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config8"]);
                        RegisterBox_hex8 = "0x0" + RegisterBox_hex8;
                    }
                    else
                    {
                        RegisterBox_hex8 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config8"]);
                        RegisterBox_hex8 = "0x" + RegisterBox_hex8;
                    }
                    mainForm.updateSPI_I2CRegisterBox8(RegisterBox_hex8);
                    //Console.WriteLine("Config8 is " + RegisterBox_hex8);
                    RR_Interval_Hi = (byte)thinkGearParser.ParsedData[i]["BMD200Config8"];

                    RR_Interval = (ushort)((RR_Interval_Hi<<8) | RR_Interval_Lo);

                    string RRInterval_str;
                    RRInterval_str = String.Format("{0:D}", RR_Interval);
                    mainForm.updateIntervalBox(RRInterval_str);

                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config9"))
                {
                    string RegisterBox_hex9;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config9"] <= 0x0F)
                    {
                        RegisterBox_hex9 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config9"]);
                        RegisterBox_hex9 = "0x0" + RegisterBox_hex9;
                    }
                    else
                    {
                        RegisterBox_hex9 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config9"]);
                        RegisterBox_hex9 = "0x" + RegisterBox_hex9;
                    }
                    mainForm.updateSPI_I2CRegisterBox9(RegisterBox_hex9);
                    //Console.WriteLine("Config9 is " + RegisterBox_hex9);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config10"))
                {
                    string RegisterBox_hex10;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config10"] <= 0x0F)
                    {
                        RegisterBox_hex10 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config10"]);
                        RegisterBox_hex10 = "0x0" + RegisterBox_hex10;
                    }
                    else
                    {
                        RegisterBox_hex10 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config10"]);
                        RegisterBox_hex10 = "0x" + RegisterBox_hex10;
                    }
                    mainForm.updateSPI_I2CRegisterBox10(RegisterBox_hex10);
                    //Console.WriteLine("Config10 is " + RegisterBox_hex10);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config11"))
                {
                    string RegisterBox_hex11;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config11"] <= 0x0F)
                    {
                        RegisterBox_hex11 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config11"]);
                        RegisterBox_hex11 = "0x0" + RegisterBox_hex11;
                    }
                    else
                    {
                        RegisterBox_hex11 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config11"]);
                        RegisterBox_hex11 = "0x" + RegisterBox_hex11;
                    }
                    mainForm.updateSPI_I2CRegisterBox11(RegisterBox_hex11);
                    //Console.WriteLine("Config11 is " + RegisterBox_hex11);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config12"))
                {
                    string RegisterBox_hex12;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config12"] <= 0x0F)
                    {
                        RegisterBox_hex12 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config12"]);
                        RegisterBox_hex12 = "0x0" + RegisterBox_hex12;
                    }
                    else
                    {
                        RegisterBox_hex12 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config12"]);
                        RegisterBox_hex12 = "0x" + RegisterBox_hex12;
                    }
                    mainForm.updateSPI_I2CRegisterBox12(RegisterBox_hex12);
                    //Console.WriteLine("Config12 is " + RegisterBox_hex12);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config13"))
                {
                    string RegisterBox_hex13;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config13"] <= 0x0F)
                    {
                        RegisterBox_hex13 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config13"]);
                        RegisterBox_hex13 = "0x0" + RegisterBox_hex13;
                    }
                    else
                    {
                        RegisterBox_hex13 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config13"]);
                        RegisterBox_hex13 = "0x" + RegisterBox_hex13;
                    }
                    mainForm.updateSPI_I2CRegisterBox13(RegisterBox_hex13);
                    //Console.WriteLine("Config13 is " + RegisterBox_hex13);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200Config14"))
                {
                    string RegisterBox_hex14;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200Config14"] <= 0x0F)
                    {
                        RegisterBox_hex14 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config14"]);
                        RegisterBox_hex14 = "0x0" + RegisterBox_hex14;
                    }
                    else
                    {
                        RegisterBox_hex14 = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200Config14"]);
                        RegisterBox_hex14 = "0x" + RegisterBox_hex14;
                    }
                    mainForm.updateSPI_I2CRegisterBox14(RegisterBox_hex14);
                    //Console.WriteLine("Config14 is " + RegisterBox_hex14);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200ConfigA"))
                {
                    string RegisterBox_hexa;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200ConfigA"] <= 0x0F)
                    {
                        RegisterBox_hexa = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigA"]);
                        RegisterBox_hexa = "0x0" + RegisterBox_hexa;
                    }
                    else
                    {
                        RegisterBox_hexa = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigA"]);
                        RegisterBox_hexa = "0x" + RegisterBox_hexa;
                    }
                    mainForm.updateSPI_I2CRegisterBox15(RegisterBox_hexa);
                    //Console.WriteLine("ConfigA is " + RegisterBox_hexa);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200ConfigB"))
                {
                    string RegisterBox_hexb;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200ConfigB"] <= 0x0F)
                    {
                        RegisterBox_hexb = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigB"]);
                        RegisterBox_hexb = "0x0" + RegisterBox_hexb;
                    }
                    else
                    {
                        RegisterBox_hexb = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigB"]);
                        RegisterBox_hexb = "0x" + RegisterBox_hexb;
                    }
                    mainForm.updateSPI_I2CRegisterBox16(RegisterBox_hexb);
                    //Console.WriteLine("ConfigB is " + RegisterBox_hexb);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200ConfigC"))
                {
                    string RegisterBox_hexc;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200ConfigC"] <= 0x0F)
                    {
                        RegisterBox_hexc = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigC"]);
                        RegisterBox_hexc = "0x0" + RegisterBox_hexc;
                    }
                    else
                    {
                        RegisterBox_hexc = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigC"]);
                        RegisterBox_hexc = "0x" + RegisterBox_hexc;
                    }
                    mainForm.updateSPI_I2CRegisterBox17(RegisterBox_hexc);
                    //Console.WriteLine("ConfigC is " + RegisterBox_hexc);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200ConfigD"))
                {
                    string RegisterBox_hexd;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200ConfigD"] <= 0x0F)
                    {
                        RegisterBox_hexd = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigD"]);
                        RegisterBox_hexd = "0x0" + RegisterBox_hexd;
                    }
                    else
                    {
                        RegisterBox_hexd = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigD"]);
                        RegisterBox_hexd = "0x" + RegisterBox_hexd;
                    }
                    mainForm.updateSPI_I2CRegisterBox18(RegisterBox_hexd);
                    //Console.WriteLine("ConfigD is " + RegisterBox_hexd);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200ConfigE"))
                {
                    string RegisterBox_hexe;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200ConfigE"] <= 0x0F)
                    {
                        RegisterBox_hexe = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigE"]);
                        RegisterBox_hexe = "0x0" + RegisterBox_hexe;
                    }
                    else
                    {
                        RegisterBox_hexe = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigE"]);
                        RegisterBox_hexe = "0x" + RegisterBox_hexe;
                    }
                    mainForm.updateSPI_I2CRegisterBox19(RegisterBox_hexe);
                    //Console.WriteLine("ConfigE is " + RegisterBox_hexe);
                }
                if (thinkGearParser.ParsedData[i].ContainsKey("BMD200ConfigF"))
                {
                    string RegisterBox_hexf;
                    if ((byte)thinkGearParser.ParsedData[i]["BMD200ConfigF"] <= 0x0F)
                    {
                        RegisterBox_hexf = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigF"]);
                        RegisterBox_hexf = "0x0" + RegisterBox_hexf;
                    }
                    else
                    {
                        RegisterBox_hexf = String.Format("{0:X}", (byte)thinkGearParser.ParsedData[i]["BMD200ConfigF"]);
                        RegisterBox_hexf = "0x" + RegisterBox_hexf;
                    }
                    mainForm.updateSPI_I2CRegisterBox20(RegisterBox_hexf);
                    //Console.WriteLine("ConfigF is " + RegisterBox_hexf);
                } 


#if true
                if(thinkGearParser.ParsedData[i].ContainsKey("Raw")) {

                    if (mainForm.replayEnable == true)
                    {
                        /*
                        if (loadedIndex < loadedList.Count)
                        {
                            plotCapturedData(loadedList[loadedIndex]);
                            loadedIndex++;
                        }

                        */
                        //update the buffer with loaded data
                        if (loadedIndex < loadedList.Count)
                        {
                            //loadedDataBuffer[loadedIndex] = loadedList[loadedIndex];
                            tempLoadedDataBuffer.Add(loadedList[loadedIndex]);
                            loadedIndex++;
                            //when buffer is full, plotting
                            if (loadedIndex  >= bufferSize_hp)
                            {
                                
                                //copy data
                                for (int m = 0; m < tempLoadedDataBuffer.Count; m++)
                                {
                                    loadedDataBuffer[m] = tempLoadedDataBuffer[m];
                                }
                               
                                //filter the data
                                filtered = applyFilter(loadedDataBuffer, hp_coeff);
                                //if "delay" seconds have passed, start plotting the data
                                if (loadedIndex >= delay)
                                {
                                    //mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), filtered));
                                    mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), (double)thinkGearParser.ParsedData[i]["Raw"]));
                                    mainForm.rawGraphPanel.LineGraph.timeStampIndex++;
                                }

                                //clear the graph when it's full
                                if (mainForm.rawGraphPanel.LineGraph.timeStampIndex >= mainForm.rawGraphPanel.LineGraph.numberOfPoints)
                                {
                                    mainForm.rawGraphPanel.LineGraph.Clear();
                                }
                                //shift buffer window 
                                tempLoadedDataBuffer.RemoveAt(0);
                            }
                         
                        }
                        
                    }

                    else if(mainForm.replayEnable == false)
                    {
                        //if signal is good
                        //if (mainForm.poorQuality == 0)
                        if (true)
                        {
                            rawCounter++;

                            double rr = respRate.calculateRespiratoryRate((short)thinkGearParser.ParsedData[i]["Raw"], (byte)mainForm.poorQuality);
                            if (rr > 0)
                            {
                                //display this
                                mainForm.updateRespirationRateIndicator(((int)rr).ToString());
                                Console.WriteLine("rr = " + rr);
                            }
                            ///////////////////////////////////////////////////////////////////////smooth_raw_filters///////////////////////////////////////////////////////////////////////
                            resampled = interplated((short)thinkGearParser.ParsedData[i]["Raw"]);

                            if (resampled != -1000000)
                            {
                                bw = baselineRemove(resampled);

                                notched = powerLine60Hz(bw);

                                filteredRui = cpf((short)notched);

                            }

                            //update the buffer with the latest eeg value
                            Array.Copy(eegBuffer, 1, tempeegBuffer, 0, bufferSize_hp - 1);
                            tempeegBuffer[bufferSize_hp - 1] = (double)thinkGearParser.ParsedData[i]["Raw"];
                            Array.Copy(tempeegBuffer, eegBuffer, bufferSize_hp);
                            bufferCounter_raw++;


                            //if the eeg buffer is full, calculate the filtered data
                            if (bufferCounter_raw >= bufferSize_hp)
                            {

                                //filter the data
                                filtered = applyFilter(eegBuffer, hp_coeff);

                                //pass filtered data to the TGHRV algorithm 
                                tgHRVresult = tgHRV.AddData((short)filtered);

                                //calulate the fatigue level
                                mainForm.calculateFatigue(tgHRVresult);

                                //update the label and play the beep (only if "delay" seconds have passed)
                                if ((tgHRVresult > 150) && (tgHRVresult < 800) && (rawCounter >= delay))
                                {
                                    tgHRVresultInMS = (int)(tgHRVresult * 1000.0 / 512.0);
                                    mainForm.updateHRVLabel(tgHRVresultInMS.ToString() + " ms");
                                    //mainForm.updateIntervalBox(tgHRVresultInMS.ToString());
                                    mainForm.playBeep();
                                }

                                //if "delay" seconds have passed, start plotting the data
                                if (rawCounter >= delay)
                                {
                                    //mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), filtered));
                                    //mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), filteredRui));
                                    mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), (double)thinkGearParser.ParsedData[i]["Raw"]));
                                    mainForm.rawGraphPanel.LineGraph.timeStampIndex++;
                                    //Console.WriteLine("raw data = " + (double)thinkGearParser.ParsedData[i]["Raw"]);
                                }

                                //clear the graph when it's full
                                if (mainForm.rawGraphPanel.LineGraph.timeStampIndex >= mainForm.rawGraphPanel.LineGraph.numberOfPoints)
                                {
                                    mainForm.rawGraphPanel.LineGraph.Clear();
                                }

                            }
                            else
                            {
                                //raw buffer is not full yet. plot zero
                                mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), 0));
                                mainForm.rawGraphPanel.LineGraph.timeStampIndex++;
                            }

                        }
                        else
                        {
                            //otherwise signal is bad, plot zero. reset counter. reset HRV
                            rawCounter = 0;
                            bufferCounter_raw = 0;
                            ResetRui();

                            Array.Clear(eegBuffer, 0, eegBuffer.Length);

                            respRate.calculateRespiratoryRate(0, 0);    //reset the respiration buffer

                            mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), 0));
                            mainForm.rawGraphPanel.LineGraph.timeStampIndex++;

                            mainForm.updateHRVLabel("0");
                            mainForm.updateAverageHeartRateLabel("0");
                            mainForm.updateRealTimeHeartRateLabel("0");
                            mainForm.updateHBRBox("0");
                            mainForm.updateIntervalBox("0");
                            //mainForm.updateHeartAgeIndicator("0");
                            //mainForm.updateRespirationRateIndicator("0");

                            tgHRV.Reset();
                        }
                     
                    }
                    
                }
#endif

#if true
                if (thinkGearParser.ParsedData[i].ContainsKey("Raw200"))
                {
                    
                    if (mainForm.replayEnable == true)
                    {

                        //update the buffer with loaded data
                        if (loadedIndex < loadedList.Count)
                        {
                            //loadedDataBuffer[loadedIndex] = loadedList[loadedIndex];
                            tempLoadedDataBuffer.Add(loadedList[loadedIndex]);
                            loadedIndex++;
                            //when buffer is full, plotting
                            if (loadedIndex >= bufferSize_hp_600)
                            {

                                //copy data
                                for (int m = 0; m < tempLoadedDataBuffer.Count; m++)
                                {
                                    loadedDataBuffer_600[m] = tempLoadedDataBuffer[m];
                                }

                                //filter the data
                                filtered = applyFilter(loadedDataBuffer_600, hp_coeff_600);
                                //if "delay" seconds have passed, start plotting the data
                                if (loadedIndex >= delay)
                                {
                                    mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), filtered));
                                    mainForm.rawGraphPanel.LineGraph.timeStampIndex++;
                                }

                                //clear the graph when it's full
                                if (mainForm.rawGraphPanel.LineGraph.timeStampIndex >= mainForm.rawGraphPanel.LineGraph.numberOfPoints)
                                {
                                    mainForm.rawGraphPanel.LineGraph.Clear();
                                }
                                //shift buffer window 
                                tempLoadedDataBuffer.RemoveAt(0);
                            }

                        }

                    }

                    else if (mainForm.replayEnable == false)
                    {
                        //if signal is good
                        //if (mainForm.poorQuality == 0)
                
                        if (true)
                        {
                            rawCounter++;
                            nskECGreSamplerInit(600,512);
                            //double rr = respRate.calculateRespiratoryRate((short)thinkGearParser.ParsedData[i]["Raw200"], (byte)mainForm.poorQuality);
                            //if (rr > 0)
                            //{
                            //    //display this
                            //    mainForm.updateRespirationRateIndicator(((int)rr).ToString());
                            //    Console.WriteLine("rr = " + rr);
                            //}
                            ///////////////////////////////////////////////////////////////////////smooth_raw_filters///////////////////////////////////////////////////////////////////////
                            //resampled = interplated((short)thinkGearParser.ParsedData[i]["Raw200"]);

                            if (resampled != -1000000)
                            {
                                sample_Before[FFT_RAW++] = (double)thinkGearParser.ParsedData[i]["Raw200"];
                                if (FFT_RAW >= 600)
                                {
                                    FFT_RAW = 0;
                                    for (int j = 0; j < 600; j++)
                                    {
                                        nskECGreSampler((int)sample_Before[j], callback);                                    
                                    }
                                    for (int number = 0; number < 512; number++)
                                    {
                                        //初始化复数的实虚部.
                                        Complex[number].real = sample_After[number];
                                        Complex[number].imag = 0;
                                    }
                                        fft.FFT(Complex, 512);//开始FFT转换
                                        //for (int number = 0; number < 512; number++)
                                        //{
                                        //    Console.WriteLine("number=" + number);
                                        //    Console.WriteLine("Complex.real" + Complex[number].real + "Complex.imag" + Complex[number].imag);
                                        //}
                                          fft_amp = fft.amplitude(Complex, 512); //FFT后的幅值
                                          Console.WriteLine("The amp value will be output:");
                                          for (int k = 1; k <= 512; k++)
                                          {
                                              ///chear: output the data to drawing FFT graphic
                                              Console.WriteLine(fft_amp[k-1]);
                                          }
                                }
                                                        
                             /*   string line;
                                int line_number=0;
                                double[] example = new double[1024];
                                while (true)
                                {
                                   
                                    System.IO.StreamReader file = new System.IO.StreamReader(@"stand_sin_ecg_1hz.txt");
                                    while ((line = file.ReadLine()) != null)
                                    {

                                        line_number++;
                                        example[line_number] = double.Parse(line);
                                        if (line_number >= 1023)
                                        {
                                            line_number = 0;
                                            for (int number = 0; number < 1024; number++)
                                            {
                                                //初始化复数的实虚部.
                                                Complex[number].real = example[number];
                                                Complex[number].imag = 0;
                                            }
                                            fft.FFT(Complex, 1024);//开始FFT转换
                                            for (int number = 0; number < 1024; number++)
                                            {
                                                Console.WriteLine("number=" + number);
                                                Console.WriteLine("Complex.real" + Complex[number].real + "Complex.imag" + Complex[number].imag);
                                            }
                                            fft_amp = fft.amplitude(Complex, 1024); //FFT后的幅值
                                            for (int k = 0; k < 1024; k++)
                                            {
                                                ///chear: output the data to drawing FFT graphic
                                                Console.WriteLine(fft_amp[k]);
                                            }

                                        
                                        }
                                        Console.WriteLine("line is:" + line.ToString());
                                       
                                        try
                                        {

                                        }
                                        catch (FormatException)
                                        {
                                            Console.ReadLine();
                                        }
                                    }

                                    file.Close();

                                }*/

                                bw = baselineRemove((short)thinkGearParser.ParsedData[i]["Raw200"]);

                                notched = powerLine60Hz(bw);

                                filteredRui = cpf((short)notched);

                            }

                            //update the buffer with the latest eeg value
                            //Array.Copy(eegBuffer_600, 1, tempeegBuffer_600, 0, bufferSize_hp_600 - 1);
                            //tempeegBuffer_600[bufferSize_hp_600 - 1] = (double)thinkGearParser.ParsedData[i]["Raw200"];
                            //Array.Copy(tempeegBuffer_600, eegBuffer_600, bufferSize_hp_600);
                            //bufferCounter_raw++;

                            //if the eeg buffer is full, calculate the filtered data
                            //if (bufferCounter_raw >= bufferSize_hp_600)
                            if (false)
                            {

                                //filter the data
                                //filtered = applyFilter(eegBuffer_600, hp_coeff_600);

                                //pass filtered data to the TGHRV algorithm 
                                tgHRVresult = tgHRV.AddData((short)filteredRui);

                                //calulate the fatigue level
                                //mainForm.calculateFatigue(tgHRVresult);

                                //update the label and play the beep (only if "delay" seconds have passed)
                                if ((tgHRVresult > 150) && (tgHRVresult < 800) && (rawCounter >= delay))
                                {
                                    tgHRVresultInMS = (int)(tgHRVresult * 1000.0 / 600.0);
                                    mainForm.updateHRVLabel(tgHRVresultInMS.ToString() + " ms");
                                    //mainForm.updateIntervalBox(tgHRVresultInMS.ToString());
                                    mainForm.playBeep();
                                }

                                //if "delay" seconds have passed, start plotting the data
                                if (rawCounter >= delay)
                                {
                                    //mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), filtered));
                                    //mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), filteredRui));
                                    mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), (double)thinkGearParser.ParsedData[i]["Raw200"]));
                                    mainForm.rawGraphPanel.LineGraph.timeStampIndex++;
                                    //Console.WriteLine("raw data = " + (double)thinkGearParser.ParsedData[i]["Raw200"]);
                                }

                                //clear the graph when it's full
                                if (mainForm.rawGraphPanel.LineGraph.timeStampIndex >= mainForm.rawGraphPanel.LineGraph.numberOfPoints)
                                {
                                    mainForm.rawGraphPanel.LineGraph.Clear();
                                }

                            }
                            else
                            {
                                //raw buffer is not full yet. plot zero
                                mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), 0));
                                mainForm.rawGraphPanel.LineGraph.timeStampIndex++;
                            }

                        }
                        else
                        {
                            //otherwise signal is bad, plot zero. reset counter. reset HRV
                            rawCounter = 0;
                            bufferCounter_raw = 0;
                            ResetRui();

                            Array.Clear(eegBuffer_600, 0, eegBuffer_600.Length);

                            respRate.calculateRespiratoryRate(0, 0);    //reset the respiration buffer

                            mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), 0));
                            mainForm.rawGraphPanel.LineGraph.timeStampIndex++;

                            mainForm.updateHRVLabel("0");
                            mainForm.updateAverageHeartRateLabel("0");
                            mainForm.updateRealTimeHeartRateLabel("0");
                            mainForm.updateHBRBox("0");
                            mainForm.updateIntervalBox("0");
                            //mainForm.updateHeartAgeIndicator("0");
                            //mainForm.updateRespirationRateIndicator("0");

                            tgHRV.Reset();
                        }

                    }

                }
#endif

                if (thinkGearParser.ParsedData[i].ContainsKey("MultiRawCount"))
                {
                    //Console.WriteLine("Number of samples in one packet: " + (((double)thinkGearParser.ParsedData[i]["MultiRawCount"])/2));
                }

                if (thinkGearParser.ParsedData[i].ContainsKey("HWHeartRate"))
                {
                    if (rawCounter >= delay)
                    {
                        mainForm.updateHBRBox(thinkGearParser.ParsedData[i]["HWHeartRate"].ToString());
                    }
                    else
                    {
                        mainForm.updateHBRBox("0");
                    }
                    
                }

                if (thinkGearParser.ParsedData[i].ContainsKey("ChipRRinterval"))
                {
                    if (rawCounter >= delay)
                    {
                        mainForm.updateIntervalBox(thinkGearParser.ParsedData[i]["ChipRRinterval"].ToString());
                    }
                    else
                    {
                        mainForm.updateIntervalBox("0");
                    }

                }

                if(thinkGearParser.ParsedData[i].ContainsKey("HeartRate")) {
                    
                    //if the "delay" number of seconds have passed, pass the heartrate value
                    if(rawCounter >= delay) {
                        mainForm.ASICHBValue = thinkGearParser.ParsedData[i]["HeartRate"];
                        mainForm.updateAverageHeartBeatValue(thinkGearParser.ParsedData[i]["HeartRate"]);
                        mainForm.updateRealTimeHeartBeatValue(thinkGearParser.ParsedData[i]["HeartRate"]);
                        //mainForm.updateHBRBox(thinkGearParser.ParsedData[i]["HeartRate"].ToString());
                    }
                        //otherwise just pass a value of 0 to make it think its poor signal
                    else {
                        mainForm.updateAverageHeartBeatValue(0);
                        mainForm.updateRealTimeHeartBeatValue(0);

                        //but still pass the correct heartbeat value for ecglog.txt
                        mainForm.ASICHBValue = thinkGearParser.ParsedData[i]["HeartRate"];
                    }
                }

                /* End "Check for the data flag for each panel..." */
            }
        }





        void OnConnectButtonClicked(object sender, EventArgs e) {
            string portName = mainForm.portText.Text.ToUpper();
            portName = portName.Trim();

            if(portName == "AUTO") {
                connector.RefreshAvailableConnections();
                mainForm.updateStatusLabel("Searching for MindSet...");
                return;
            }

            int portNumber = 0;

            try {
                portNumber = Convert.ToInt16(portName);
            } catch(FormatException fe) {
                Console.WriteLine(fe.Message);
            }

            if(portNumber > 0) {
                portName = "COM" + portNumber;
            }

            Regex r = new Regex("COM[1-9][0-9]*");
            portName = r.Match(portName).ToString();
            Console.WriteLine("Connecting to xx" + portName + "xx");

            if(portName != "") {
                connector.Connect(portName);
                mainForm.updateStatusLabel("Connecting to " + portName);
                return;
            }

            MessageBox.Show("You must enter a valid COM port name. (Ex. COM1 or 1)\nYou may also type in 'Auto' for auto-connection.", "Invalid Input Error",
                            MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
            //mainForm.updateConnectButton(false);
            mainForm.updateConnectButton(false);
            return;

        }

        void OnDisconnectButtonClicked(object sender, EventArgs e) {
            connector.Disconnect();
            mainForm.updateConnectButton(false);
            mainForm.replayEnable = false;
            //make the byteToSend null so it will be resent when pressing connect
            bytesToSend = null;
        }

        void OnStopReplayButtonClicked(object sender, EventArgs e)
        {
            mainForm.replayEnable = false;
            mainForm.Replay.Visible = true;
            mainForm.stopReplay.Visible = false;
        }

        void setUARTOpenCmdByte(byte[] myByte)
        {
            /*call 'ThinkGear' to send UART byte*/
            //byte[] myByte1 = { 0xAA, 0xAA, 0x04, 0x03, 0x00, 0xFB, 0x07, (byte)mainForm.TrimByte };
            connector.Send(device.PortName, myByte);
        }

        void setUARTCloseCmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void setSPIOpenCmdByte(byte[] myByte)
        {
            //byte[] myByte1 = { 0xAA, 0xAA, 0x04, 0x03, 0x00, 0xFB, 0x07, (byte)mainForm.TrimByte };
            connector.Send(device.PortName, myByte);
        }

        void setSPICloseCmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void setI2COpenCmdByte(byte[] myByte)
        {
            //byte[] myByte1 = { 0xAA, 0xAA, 0x04, 0x03, 0x00, 0xFB, 0x07, (byte)mainForm.TrimByte };
            connector.Send(device.PortName, myByte);
        }

        void setI2CCloseCmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void setUARTWriteCmdByte(byte[] myByte)
        {

            //byte[] myByte1 = { 0xAA, 0xAA, 0x04, 0x03, 0x00, 0xFA, 0x00, (byte)mainForm.TrimByte };
            //WriteByte = myByte1;
            //MessageBox.Show(Convert.ToString(WriteByte));

            connector.Send(device.PortName, myByte);
            
        }

        void setSPI_I2CWriteCmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void setClockFrequencyWriteCmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void setSamplingRate300CmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void setSamplingRate600CmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void SetUartReadCmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        void SetSpiReadCmdByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }
        void SetTrimByteReadCmdByte(byte[] myByte)
        {
            //byte[] myByte1 = { 0xAA, 0xAA, 0x04, 0x03, 0x00, 0xFB, 0x07, (byte)mainForm.TrimByte };
            connector.Send(device.PortName, myByte);
        }

        void seteFuseByte(byte[] myByte)
        {
            connector.Send(device.PortName, myByte);
        }

        delegate void UpdateVisibilityDelegate(bool enable);
        public void UpdateVisibility(bool enable) {
            if(this.InvokeRequired) {
                UpdateVisibilityDelegate del = new UpdateVisibilityDelegate(UpdateVisibility);
                this.Invoke(del, new object[] { enable });
            } else {
                if(enable) {
                    if(!this.Visible) {
                        this.Show();
                        mainForm.Hide();
                    }
                } else {
                    if(this.Visible) {
                        this.Hide();
                        mainForm.Show();
                    }
                }
            }
        }


        delegate void UpdateConnectButtonDelegate(bool connected);
        public void UpdateConnectButton(bool connected) {
            if(this.InvokeRequired) {
                UpdateConnectButtonDelegate del = new UpdateConnectButtonDelegate(UpdateConnectButton);
                this.Invoke(del, new object[] { connected });
            } else {
                if(connected) {
                    this.button1.Enabled = false;
                } else {

                    this.button1.Enabled = true;
                }

            }
        }

        void OnMainFormDisposed(object sender, EventArgs e) {
            this.Dispose();
        }

        private void Launcher_Load(object sender, EventArgs e) {

        }


        //apply filter based on multiply add technique
        private double applyFilter(double[] data, double[] coeffs) {
            int length = data.Length;
            double result = new double();

            for(int i = 0; i < length; i++) {
                result += data[i] * coeffs[i];
            }
            return result;
        }

        //capture high byte and low byte data from loaded file
        private void captureData(string loadedFile, List<short> loadedList)
        {
            string[] tem = loadedFile.Split('\n');
            for (int i = 1; i < (tem.Length - 1); i++)//the last line is empty,just filter it
            {
                string[] temp = tem[i].Split(' ');
                //System.Text.UTF8Encoding encoding = new System.Text.UTF8Encoding();
                byte high, low;
                short temp_raw = 0;
                //only parse the good signal raw data
                if (Int32.Parse(temp[1]) == 80)
                {
                    high = Convert.ToByte(temp[2],16);
                    low = Convert.ToByte(temp[3], 16);
                    temp_raw = (short)((high << 8) + low);
                    loadedList.Add(temp_raw);
                }
                
            }
        }

        //plot loaded data
        private void plotCapturedData(short loadedRawData)
        {
            mainForm.rawGraphPanel.LineGraph.Add(new DataPair((mainForm.rawGraphPanel.LineGraph.timeStampIndex / (double)mainForm.rawGraphPanel.LineGraph.samplingRate), loadedRawData));
            mainForm.rawGraphPanel.LineGraph.timeStampIndex++;
            
            //clear the graph when it's full
            if (mainForm.rawGraphPanel.LineGraph.timeStampIndex >= mainForm.rawGraphPanel.LineGraph.numberOfPoints)
            {
                mainForm.rawGraphPanel.LineGraph.Clear();
            }
            
        }

        ///////////////////////////////////////////////////////////////////////smoot_filter_functions///////////////////////////////////////////////////////////////////////
        private void ResetRui()
        {  // buffer size
            n1 = 6;
            n3 = 8;
            n5 = 10;
            n7 = 12;
            n9 = 14;
            // average size
            m1 = 3;
            m3 = 5;
            m5 = 7;
            m7 = 9;
            m9 = 11;
            // linear criterion 
            thre1 = 2780;
            thre3 = 1800;
            thre5 = 1000;
            thre7 = 900;
            thre9 = 500;
            // buffers
            y1 = new int[n1];
            for (int i = 0; i < n1; i++)
            {
                y1[i] = 0;
            }

            y3 = new int[n3];
            for (int i = 0; i < n3; i++)
            {
                y3[i] = 0;
            }

            y5 = new int[n5];
            for (int i = 0; i < n5; i++)
            {
                y5[i] = 0;
            }

            y7 = new int[n7];
            for (int i = 0; i < n7; i++)
            {
                y7[i] = 0;
            }

            y9 = new int[n9];
            for (int i = 0; i < n9; i++)
            {
                y9[i] = 0;
            }

            fs = 512;
            rfs = 300;

            step = (double)fs / (double)rfs;

            iy1 = 0;
            iy2 = 0;

            p = 1;
            np = 0;

            xi = 0;

            fpl = 60;
            N = rfs / fpl;

            M = 3000;   // linear criteria for notch

            end_xb = N + 2;
            mid_xb = (N + 1) / 2;

            xb = new int[end_xb];
            for (int i = 0; i < end_xb; i++)
            {
                xb[i] = 0;
            }

            bb = new int[N];
            for (int i = 0; i < N; i++)
            {
                bb[i] = 0;
            }

            n_yb = 3;

            yb = new int[n_yb];
            for (int i = 0; i < n_yb; i++)
            {
                yb[i] = 0;
            }


            D = 10; // fs = 300 Hz, fpl = 60 Hz
            N1 = 41;
            bufferSize = 401;

            s = new int[bufferSize];
            for (int i = 0; i < bufferSize; i++)
            {
                s[i] = 0;
            }



        } // end reset


        // conditional partial filtering (cpf)
        private int cpf(short data) //(short data)
        {
            int fy = 0; // return filtered data
            int t1;
            int Th1, Th3, Th5, Th7, Th9;

            int[] diff1;
            diff1 = new int[n1 - 1];
            int[] diff3;
            diff3 = new int[n3 - 1];
            int[] diff5;
            diff5 = new int[n5 - 1];
            int[] diff7;
            diff7 = new int[n7 - 1];
            int[] diff9;
            diff9 = new int[n9 - 1];

            for (int i = n1 - 1; i > 0; i--)
            {
                y1[i] = y1[i - 1];
            }

            y1[0] = data;

            for (int i = n3 - 1; i > 0; i--)
            {
                y3[i] = y3[i - 1];
            }

            for (int i = n5 - 1; i > 0; i--)
            {
                y5[i] = y5[i - 1];
            }

            for (int i = n7 - 1; i > 0; i--)
            {
                y7[i] = y7[i - 1];
            }

            for (int i = n9 - 1; i > 0; i--)
            {
                y9[i] = y9[i - 1];
            }


            // y1 --> y3
            /*      for (int j = 0; j < n1 - 1; j++)
                  {
                      diff1[j] = absRui(y1[0] - y1[j + 1]);
                  } */

            t1 = findMaxRui(y1) - findMinRui(y1);

            if (t1 < thre1)
            {
                if (t1 < thre3)
                {
                    if (t1 < thre5)
                    {
                        Th1 = thre5;
                        Th3 = Th1 - 200;
                        Th5 = Th3 - 200;
                        Th7 = Th5 - 100;
                        Th9 = Th7 - 100;
                    }
                    else
                    {
                        Th1 = thre3;
                        Th3 = Th1 - 500;
                        Th5 = Th3 - 300;
                        Th7 = Th5 - 200;
                        Th9 = Th7 - 100;
                    }
                }
                else
                {
                    Th1 = (thre1 + thre3) / 2;
                    Th3 = Th1 - 800;
                    Th5 = Th3 - 600;
                    Th7 = 900;
                    Th9 = 500;
                }
            }
            else
            {
                Th1 = thre1;
                Th3 = thre3;
                Th5 = thre5;
                Th7 = thre7;
                Th9 = thre9;
            }

            int sum1 = 0;
            if ((findMaxRui(y1) - findMinRui(y1)) < Th1)
            {
                for (int k = 2; k <= m1; k++)  //for (int k = 2; k <= m1 + 1; k++)
                {
                    sum1 += y1[k];
                }

                y3[0] = sum1 / (m1 - 1); //(sum1/m1);
            }
            else
            {
                y3[0] = y1[n1 / 2];
            }


            // y3 --> y5
            /*     for (int j = 0; j < n3 - 1; j++)
                 {
                     diff3[j] = absRui(y3[0] - y3[j + 1]);
                 }  */

            int sum3 = 0;
            if ((findMaxRui(y3) - findMinRui(y3)) < Th3)
            {
                for (int k = 2; k <= m3 + 1; k++)
                {
                    sum3 += y3[k];
                }
                y5[0] = (sum3 / m3);
            }
            else
            {
                y5[0] = y3[n3 / 2];
            }


            // y5 --> y7
            /*       for (int j = 0; j < n5 - 1; j++)
                   {
                       diff5[j] = absRui(y5[0] - y5[j + 1]);
                   }  */

            int sum5 = 0;
            if ((findMaxRui(y5) - findMinRui(y5)) < Th5)
            {
                for (int k = 2; k <= m5 + 1; k++)
                {
                    sum5 += y5[k];
                }
                y7[0] = (sum5 / m5);
            }
            else
            {
                y7[0] = y5[n5 / 2];

            }



            // y7 --> y9
            /*       for (int j = 0; j < n7 - 1; j++)
                   {
                       diff7[j] = absRui(y7[0] - y7[j + 1]);
                   }  */

            int sum7 = 0;
            if ((findMaxRui(y7) - findMinRui(y7)) < Th7)
            {
                for (int k = 2; k <= m7 + 1; k++)
                {
                    sum7 += y7[k];
                }
                y9[0] = (sum7 / m7);
            }
            else
            {
                y9[0] = y7[n7 / 2];
            }



            // y9 --> fy
            /*       for (int j = 0; j < n9 - 1; j++)
                   {
                       diff9[j] = absRui(y9[0] - y9[j + 1]);
                   }  */

            int sum9 = 0;
            if ((findMaxRui(y9) - findMinRui(y9)) < Th9)
            {
                for (int k = 2; k <= m9 + 1; k++)
                {
                    sum9 += y9[k];
                }

                fy = (sum9 / m9);
            }
            else
            {
                fy = y9[n9 / 2];
            }

            return fy;


        } // end cpf

        private int interplated(short data)
        {
            // step = fs / rfs;
            // fs: original sample frequency
            // rfs: resample frequency

            int yo = -1000000;

            iy1 = iy2;
            iy2 = data;

            xi = 1 + (p - 1) * step;

            if (xi == 1)
            {
                yo = (int)data;
                p = p + 1;
                //Console.WriteLine("1");
            }
            else if (xi <= (np + 1.0) && xi > np)
            {
                if (abs(xi - np) < abs(xi - (np + 1)))
                {

                    yo = (int)(iy1 + (xi - np) * (iy2 - iy1));
                }
                else
                {

                    yo = (int)(iy2 + (xi - (np + 1)) * (iy2 - iy1));
                }

                p = p + 1;

            }
            else
            {
                yo = -1000000;

            }


            np++;


            return yo;

        }

        // remove 60Hz power line noise
        private int powerLine60Hz(int data)
        {
            int y = 0;  // return
            int Ds; // 2nd differential
            int Bs; // correction

            // new data point comes in
            for (int i = end_xb - 1; i > 0; i--)
            {

                xb[i] = xb[i - 1];
            }

            xb[0] = data; //resample.interplate(signalquality, data, step);

            for (int i = n_yb - 1; i > 0; i--)
            {

                yb[i] = yb[i - 1];
            }


            Ds = absRui((xb[end_xb - 1] - xb[1]) + (xb[end_xb - 2] - xb[0]));

            int[] pxb = new int[end_xb - 2];
            Array.Copy(xb, pxb, end_xb - 2);

            if (Ds < M)
            {

                y = findSum(pxb);
                y = y / N;

                Bs = xb[mid_xb] - y;
            }
            else
            {

                Bs = bb[N - 1];

                y = xb[mid_xb] - Bs;

            }

            yb[0] = y;

            for (int j = N - 1; j > 0; j--)
            {

                bb[j] = bb[j - 1];
            }

            bb[0] = Bs;

            return findSum(yb) / n_yb;

        }

        private int baselineRemove(int data)
        {

            int y = 0;
            int sum = 0;

            for (int i = bufferSize - 1; i > 0; i--)
            {

                s[i] = s[i - 1];
            }

            s[0] = data;


            for (int j = 0; j <= 40; j++)
            {

                sum = sum + s[j * D];
            }

            y = s[(bufferSize - 1) / 2] - sum / N1;

            return y;
        }

        //calculate the max value
        private int findMaxRui(int[] x)
        {
            int max = x[0];

            for (int i = 0; i < x.Length; i++)
            {
                if (x[i] > max)
                {
                    max = x[i];
                }
            }

            return max;
        }

        //calculate the min value
        private int findMinRui(int[] x)
        {
            int min = x[0];

            for (int i = 0; i < x.Length; i++)
            {
                if (x[i] < min)
                {
                    min = x[i];
                }
            }

            return min;
        }

        //calculate the absolute value
        private int absRui(int x)
        {
            int abs;

            if (x >= 0)
            {
                abs = x;
            }
            else
            {
                abs = -x;
            }

            return abs;
        }

        private double abs(double x)
        {
            double abs;

            if (x >= 0)
            {
                abs = x;
            }
            else
            {
                abs = -x;
            }

            return abs;
        }

        private int findSum(int[] x)
        {
            int sum = 0;

            for (int i = 0; i < x.Length; i++)
            {

                sum = sum + x[i];
            }

            return sum;

        }
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }
}
